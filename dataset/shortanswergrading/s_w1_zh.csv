1	3.5	[6]	在原型程序中解决高风险问题，以确保程序可行。 原型也可用于向公司显示软件可能进行编程。<br><br>
1	5	[5]	使用快速、简单的程序来模拟所需最终产品的某些部分，该程序可执行小型特定工作。这是一种帮助查看问题是什么以及如何在最终项目中解决它的方法。
1	4	[8]	原型程序模拟所需软件产品部分的行为，以便进行错误检查。
1	5	[3]	在规范阶段定义原型可刺激所需软件产品部分的行为。 这意味着，原型的作用是一个临时的解决方案，直到程序本身被完善，以广泛用于解决问题。
1	3	[4]	它用于让用户对已完成的程序有第一个想法，并允许客户端评估程序。这可以产生很多反馈，包括软件规范和项目估计整个项目。
1	2	[24]	在程序最终确定之前查找问题和错误
1	2.5	[9]	解决创建程序中的主要问题。没有办法解释程序中所有可能的 Bug，但可以证明程序是有形的。
1	5	[22]	您可以将整个程序分解为原型程序，以模拟最终程序的一部分
1	3.5	[23]	-提供完成的程序应如何执行的示例或模型。<br>-为一些将遇到的挑战提供了远见卓识。<br>-提供机会对已完成的程序进行更改。
1	5	[2]	仅模拟所需软件产品的一部分行为。
1	5	[29]	刺激所需软件产品部分行为的程序。
1	5	[31]	模拟所需软件产品部分行为的程序。
1	2	[12]	布置基础知识，并给出实际问题解决的起点。
1	4.5	[21]	模拟问题部分的解决
1	2	[13]	原型程序提供了一个基本的基础，从中可以进一步增强和改进问题的解决方案。
1	4.5	[11]	原型程序是软件问题索尔文规范阶段的一部分。 它被用来说明如何在程序中解决关键问题或问题，有时作为扩展的基础程序。
1	5	[17]	模拟所需软件产品部分行为的程序
1	2	[7]	它提供了有限的概念验证，在实际编程整个应用程序之前与客户端进行验证。<br>
1	2	[10]	它测试程序的主要功能，同时留下更精细的细节。<br>
1	2.5	[27]	在开发的早期阶段从用户获得早期反馈。 向用户展示程序将做什么/外观的第一个想法。 确保程序在密集编程开始前满足要求。
1	5	[20]	它模拟所需软件产品部分的行为
1	5	[18]	它模拟所需软件产品部分的行为。
1	1.5	[19]	原型程序用于解决问题，以收集问题数据。
1	2.5	[16]	简化对正在讨论的问题的理解，并简化对程序本身的理解
1	5	[26]	它模拟所需软件产品部分的行为
1	2	[1]	原型程序的作用是帮助发现实际编程过程中可能出现的关键问题。
1	3	[28]	原型程序给出了最终产品将做什么的一般想法，<br><br>没有时间和精力来写出整个程序。
1	3	[15]	以显示程序的某一部分工作，因为它应该
1	2.5	[14]	原型编程是一种编程方法，使一个人能够采取有组织的方法来开发有效的程序，在解决问题时以最小的错误和战略模式。即，书举了一个顾客从银行取款的例子，这种方法在OOA/Design lvl期间采用伪代码级别，然后开始创建解决方案。
2	3.5	[6]	如果测试阶段发现设计中的问题，可以进行优化，并可能进行设计。如果程序当前形式无法工作，这将导致生产时间晚于最初估计，生产可能会受到影响。也会影响编码，因为测试后您可能需要重写代码，程序才能删除错误。
2	4	[5]	实施阶段和维护阶段生效
2	4.5	[8]	验证、编码、优化解决方案和维护都受测试阶段的影响。
2	3	[3]	在RUP中，软件生命周期中受测试阶段影响的阶段是：<br><br>解释阶段-精炼的正向视觉、核心系统的迭代、系统需求的开发、更准确的时间和成本估算<br><br>构建阶段-剩余系统的迭代开发。<br><br>过渡阶段测试和系统的部署。
2	3	[4]	完善解决方案、生产和维护都受测试阶段的影响。
2	2	[24]	细化、构建和过渡都受测试影响
2	3.5	[9]	精炼、生产、维护
2	4	[22]	改进解决方案
2	2	[23]	-验证<br> - 调试
2	5	[2]	精炼和编码
2	2.5	[29]	细化阶段的后半部分、施工阶段和过渡阶段。<br>
2	3.5	[31]	精炼步骤、生产步骤和维护阶段。<br>
2	2	[12]	细化、 施工、过渡
2	3	[21]	精炼。
2	1.5	[13]	测试阶段对程序的最终版本有直接影响，因为它是软件修订的调试和最终完成。
2	5	[11]	直接：精炼，编码。 因为精炼就在测试阶段之前，编码就在测试阶段之后。<br><br>：生产、维护。 因为精炼发生在软件生命周期的最后两个阶段之前。
2	3.5	[17]	测试、精炼、生产和维护。
2	1.5	[7]	根据工作完成情况，测试将分散到整个<br>流程中，以防止因缺少<br>foright.<br>
2	2.5	[10]	细化、构建和过渡。
2	1.5	[27]	除设置程序要求外，所有阶段都受到影响。 如果测试失败，它可以更改程序的整个设计、实现等以及最终结果。
2	3	[20]	精炼、生产和维护
2	5	[18]	编码和精炼
2	3.5	[19]	精炼、生产、维护。
2	1	[16]	删除逻辑错误、测试有效数据、随机数据和实际数据。
2	2.5	[26]	1- 规格<br>2-设计<br>3-风险分析<br>4-验证<br>5-编码<br>6-测试<br>7-精炼<br>8-生产<br>9-维护
2	3.5	[1]	精炼阶段、生产阶段和维护阶段。<br><br>
2	2	[28]	测试可能会影响生命周期的所有部分;它会让你回到<br><br>， 如果它测试不好。
2	3	[15]	编码
2	1.5	[14]	各个组件和步骤（如分析、设计和实现代码）以及整个系统都经过测试，以执行分析阶段确定的要求。即主输出
3	4.5	[6]	模块化，能够重用程序的某些部分，有时与完全不同的程序目标。此外，通过将代码划分为每个类执行特定作业，以及当程序在一个作业中失败时，您只有一个类要调试，从而更容易调试代码。出于安全目的，它允许您允许某人使用对列表进行排序的程序，而不必赋予他们访问源代码的访问权限。ALso 允许您使用继承和多态性。
3	5	[5]	这种类型的编程更加灵活，使得添加和修改程序更加容易。 它也是一种故障安全程序的类型，您可以检查每个单独的模块。 这消除了冗余代码，使程序更易于其他程序员阅读。 调试程序时，更容易跟踪模块中问题的根源，而不是 200 万行程序。
3	3.5	[8]	面向对象编程的主要优点是现有类可以重用，并且程序维护和验证更容易。<br>
3	2.5	[3]	优点是 OOP 允许我们构建对象类。 OOP 的三个原则是：<br><br>属性- 对象结合数据和<br><br>继承 - 类可以从其他类继承属性。<br><br>变形 - 对象可以在执行时确定适当的操作。
3	3.5	[4]	一些优点是现有的类可以重用，程序维护和验证更容易完成。
3	1	[24]	面向对象的编程允许程序员将对象与类一起使用，这些类可以更改和操作，同时不影响整个对象。类都包含影响对象的操作。
3	4	[9]	可重用的组件、可扩展性、可维护性，可减少大问题，使问题更小、易于管理。
3	2.5	[22]	封装对象组合数据和操作<br>继承 -类可以从其他类继承属性<br>多态性 - 对象可以在执行时确定适当的操作
3	3	[23]	-更易于调试<br>可重复性
3	4	[2]	可维修性和易用性
3	5	[29]	其中一个主要优点是您可以隐藏内部细节，这是一种通过封装已知的技术。对象合并数据和操作，但您无法看到它的工作原理。<br>另一个优点是，您可以重用在程序中早期定义的类，这种方法称为继承。<br>另一个优点是对象可以在执行时确定适当的操作，一种称为多态性的技术。<br>
3	3.5	[31]	现有类可以重复使用，程序维护和验证更容易。
3	2	[12]	使用不同的模块可以更轻松地进行调试
3	3.5	[21]	数据封装概念，使用函数或方法来操作数据。
3	4.5	[13]	模块化、可重用的代码，允许更快地部署解决方案，并更普遍地查看解决方案。
3	5	[11]	编码和调试程序通常更容易，因为编译器将指定工作不正确的对象，或者分配给对象的函数将更易于识别。 代码本身看起来也更加有条理，更易于阅读，有助于避免冗余编码。 编程后维护也更容易。<br><br>，模块可以在其他程序中多次重复使用，而不会太麻烦。  抽象是将一个大问题分解为更小、更简单的问题并解决这些问题的艺术。 许多较小的问题在独特的复杂问题之间共享，创建模块来解决这些问题可以节省时间，当您再次遇到它们。
3	4.5	[17]	变量可以保持私有。代码易于修改和重用，也易于实现。更别提作为观察者更容易阅读和跟随了。
3	3.5	[7]	数据抽象和控制...将元素与其他元素<br>元素，防止数据被篡改。<br>
3	4	[10]	封装 - 对象在不知道操作工作原理的情况下使用操作。<br>继承 - 通过重用较早的类来减少冗余。<br>变形 - 对象选择在这种情况下使用的正确操作。
3	4.5	[27]	它们使重用和调整以前编写的代码更加容易，并且它们将复杂程序分离成更小、更易于理解的类。
3	3.5	[20]	现有类可以重复使用，程序维护和验证更容易<br>
3	3.5	[18]	现有课程可以修改，程序维护和验证更容易
3	5	[19]	面向对象编程的主要优点是数据抽象、更易于维护和可重新可用性。
3	4	[16]	现有类可以重复使用<br>程序维护和验证很容易
3	3.5	[26]	1- 现有类可重复使用<br>2- 程序维护和验证更容易<br>
3	3.5	[1]	信息可以隐藏。调试更容易。编程更容易，更容易管理。
3	3.5	[28]	现有的类可以重复使用，程序维护和验证<br><br>更可怕。
3	3.5	[15]	现有的类可以重复使用<br>和验证更容易
3	3.5	[14]	对于一个封装来说，对象内部的变量值是私有的，除非编写方法将信息传递到对象之外。以及继承，其中每个子类继承其超级类的所有变量和方法。 书中的示例包括 obj 时钟以及 obj 闹钟如何仍然使用第一类的时钟。
4	5	[6]	在函数\ t 手 （）] ™
4	5	[5]	函数主（）。
4	5	[8]	c++ 程序开始在主方法中执行。
4	5	[3]	一C++程序将开始在 main（） 函数执行。<br>
4	5	[4]	它们从主（） 函数开始。
4	5	[24]	国际主（）
4	5	[9]	主要方法
4	0	[22]	在测试阶段
4	5	[23]	-在主函数
4	5	[2]	主要
4	5	[29]	他们开始执行在 funcion 主 （） 。
4	5	[31]	主要方法。
4	2.5	[12]	在根
4	5	[21]	在主（） 函数中。
4	5	[13]	C++程序开始在主执行。
4	5	[11]	在主函数中...？
4	5	[17]	在"主（）"功能
4	5	[7]	主要功能。
4	5	[10]	功能主
4	5	[27]	加载所需的 include 语句和库后，主方法开始执行。
4	5	[20]	主要功能
4	5	[18]	主要
4	5	[19]	C++程序开始在主函数执行。
4	5	[16]	在主
4	5	[26]	他们承诺在主执行
4	5	[1]	在主函数<br><br>主 （）
4	5	[28]	C++程序开始在主函数执行。
4	5	[15]	在"主"功能中
4	5	[14]	在主函数内
5	2	[6]	变量可以是程序中的整数或字符串。
5	4.5	[5]	在编程中，一个包含数据且由程序员唯一命名的结构。它保存分配给它的数据，直到分配新值或程序完成。<br>
5	5	[8]	变量是内存中可以存储值的位置。
5	5	[3]	变量是计算机内存中的位置，可以在其中存储值，以后可以检索该值。
5	5	[4]	变量是计算机内存中可存储值以供程序使用的位置。每个变量都有一个名称、一个值、一个类型和一个大小。
5	3.5	[24]	可以保存数字或字母值的命名对象
5	4	[9]	它是值/数字的元或名称。示例："a_used_number"可以代表任何给定的数字，程序员可以使用变量名称引用该数字。
5	5	[22]	变量是计算机内存中可存储值以供程序使用的位置
5	4	[23]	-在内存中保存位置的标识符。
5	5	[2]	包含特定类型数据的内存块
5	5	[29]	它是计算机内存中可存储供程序使用的位置。
5	5	[31]	内存中可以存储值的位置。
5	3	[12]	可以假定一组值中的任何一个的值/单词
5	4	[21]	指向内存中位置的指针。
5	5	[13]	变量是特定类型存储数据的内存地址，或者从数学角度来看，表示具有更改值的固定定义的符号。
5	5	[11]	变量是计算机内存中可能发生变化的值，可由程序使用。 程序可以更改变量的值，并在以后调用它，或者直接对它采取行动。
5	4	[17]	表示值的符号，该值可能更改，也可能不更改，具体取决于程序。
5	4.5	[7]	用于保存程序中使用的信息的占位符...<br>例如：<br>int 可以容纳：1、2、3、4、68、72、256 等<br>浮动可以保持：1.54、55.55、1.24、5.657、8.8123 等<br>字符可以容纳： A， B， C， D， E， F， ！， 4， 5， 6， P <br>
5	4.5	[10]	程序使用的存储值
5	4.5	[27]	将不同值存储到程序中的方法，如数字、单词、字母等。
5	3.5	[20]	内存中可以存储值的位置的对象<br>
5	5	[18]	内存中可以存储值的位置
5	3.5	[19]	变量是存储数据的对象。
5	5	[16]	内存中可以存储值的位置。
5	5	[26]	它是内存中可以存储值的位置<br>
5	5	[1]	变量是计算机内存中可以存储值以供程序使用的位置。
5	5	[28]	变量是计算机内存中的值可以存储的位置<br><br>供程序使用。
5	5	[15]	内存中可以存储和检索数据的位置
5	5	[14]	是一个方法或标识符，我会说，我们使用绑定数据对象到内存位置;然后存储在一个位置，可以在调用变量名称时访问该位置，并在以后调用变量名称时对其进行操作。
6	2	[6]	它们可以在使用之前声明，但在程序的开头声明它们并标记它们是什么食物是一个很好的做法。
6	3	[5]	在函数 main（） 中，然后再使用变量。
6	5	[8]	局部变量在方法或函数中声明，它们将在方法的开头使用。全局变量声明在任何函数或方法之外，通常在定义函数之前。
6	4.5	[3]	变量在本地块内或全局块外部定义的地方声明。
6	4	[4]	变量在实际使用之前声明。它们可以在 main（） 之前声明为全局使用
6	2.5	[24]	为了良好的编程实践，应在 main（） 之前声明它们，但至少应在使用之前声明它们。
6	5	[9]	它们可以在主要方法之前全局声明 （但也在它之外）...或变量只能受它们在内范围的方法的受制于，但仍将在该方法的开头声明（但在该方法的开头）。
6	5	[22]	局部变量在方法内声明，而全局变量在正文中声明。
6	2	[23]	-在主函数中的任何地方。
6	4.5	[2]	全局用于整个程序，并本地用于单个函数（包括 FOR 语句）
6	3	[29]	它们通常在开始声明，然后才能在程序中使用。它们始终包含名称和数据类型。<br>
6	2.5	[31]	方法内部。
6	1.5	[12]	在顶部
6	5	[21]	全局变量在代码正文中声明。局部变量在要使用的函数中声明（除非传递函数是变量）。变量在使用前应始终声明。
6	2.5	[13]	变量通常在代码模块的开头C++声明。
6	3.5	[11]	在主函数中，通常在代码的顶部。<br><br>几乎可以在任何地方声明它们，但必须在代码使用或对它们采取行动之前声明它们。
6	2	[17]	在程序的一开始。在主（）开始前。
6	2.5	[7]	在函数声明中，对于语句和 while 语句。<br>在 If、For、同时在命名空间、标题等的正文中执行语句（几乎任何地方）。<br>程序中的任何地方， 只要它是在它自己的行。
6	1	[10]	声明变量的数据类型后。
6	3	[27]	在代码的任何地方，可以在顶部，或在代码的中间，或任何地方。
6	2	[20]	在使用它们之前。
6	3.5	[18]	在使用之前，在同一范围内的任何地方
6	2.5	[19]	变量可以在类和方法中声明。
6	5	[16]	在全局变量的情况下，在函数范围内和函数范围之外
6	4	[26]	全局变量在主函数中声明<br>在任何其他函数中声明的本地变量
6	4	[1]	变量通常在程序开始时声明C++，但只要变量在调用之前出现，就可以在程序中声明任何变量。
6	2	[28]	变量在主函数中声明，在尝试<br><br>任何操作之前。
6	4.5	[15]	任何地方， 但您声明它们取决于您希望它们可访问的地方 （它们的范围）
6	4.5	[14]	这取决于它是一个™，那么它们必须声明出要在每个作用域中使用的源代码，但是局部变量是本地函数中声明的变量等，这显然不需要在变量之外声明 ™，看看它如何用于函数或阻止其被调用。
7	4.5	[6]	[do] 语句首先计算条件，然后执行语句 0 或更多次中的代码行。<br>
7	5	[5]	做...而语句计算在运行其中包含的块后是否循环至少一次。因此，主要的区别是，虽然语句有可能永远不会被使用。做...而另一方面，在评估是否再次运行之前，始终至少运行一次语句。
7	5	[8]	一段时间和一段时间的主要区别...而循环是做...while 循环始终循环至少循环一次，但 while 循环并不总是这样做。
7	5	[3]	While 循环用于执行代码块，只要某些条件为 true。 A 做...而循环用于执行代码块，只要满足某些条件。 时与做的区别...而是当循环测试其条件之前执行其内容和 do...而循环在执行其内容后至少测试一次其条件。
7	5	[4]	do...while 语句通常在循环的末尾，因此它至少运行一次。至于 while 语句，如果条件一开始为 false，则循环将永远不会运行。
7	5	[24]	while 循环将检查语句，以确保它在执行之前为 true。在检查语句以查看是否应该再次运行之前，将执行 do while 循环。
7	5	[9]	while 语句将测试 while 循环 FIRST 的条件 - 循环可能永远不会运行。A 做...while 循环将始终运行一次，然后 while 测试将确定它是否会再次运行。
7	5	[22]	做，而循环总是执行一次。while 循环的条件语句必须为 true 才能运行。
7	5	[23]	-WHILE 语句 - 条件检查是否有效，然后重复，直到凹凸不成天。<br><br>做...WHILE 语句 - 代码至少执行一次，然后检查为有效条件。 将继续<br>
7	5	[2]	而语句将在执行循环（包括第一个循环）之前对语句进行计算，这意味着 while 循环不会始终执行。A 做...同时将运行计算语句后运行循环的循环，确保循环始终执行至少一次。
7	5	[29]	做和做的主要区别...当语句在做...而语句是 do 块中的语句始终至少执行一次。<br> while 语句仅在其条件为 true 时才执行。
7	4.5	[31]	do 的循环...而语句始终执行一次。
7	5	[12]	while 语句将仅在满足语句时处理， 而 do...而将始终处理一次，则仅在满足语句时继续。
7	4	[21]	做...虽然运行嵌入代码至少一次，do 命令不一定
7	5	[13]	在运行前先测试 true 时， 请...而先运行一次，然后检查。
7	5	[11]	A 做...而语句的正文始终执行至少一次。 其中 while while 语句将不执行，除非 时的条件为 true。
7	5	[17]	无论条件如何，do while 循环块中的语句将始终至少执行一次。而如果条件未得到满足，则可能永远不会执行 while 循环。
7	5	[7]	一个做...while 循环将始终运行一次，而 while 循环<br>运行循环之前执行测试。
7	5	[10]	while 语句在条件可以启动之前测试条件。<br>做...而语句在测试条件之前循环一次。
7	3.5	[27]	while 循环在循环的开头终止，do/while 在循环的末尾终止。
7	3.5	[20]	循环体始终至少执行一次<br>
7	5	[18]	While 循环在其循环的顶部计算其表达式，并决定是否需要执行，Do-while 始终至少执行一次，然后在循环的底部计算其表达式。
7	5	[19]	A 做...while 语句在检查条件之前将始终至少执行一次"do"代码。while 语句将始终首先检查条件。
7	5	[16]	但是，在检查条件之前，执行时间至少经过 1 次，如果条件最初失败，则一段时间将无法进入循环。
7	5	[26]	while 循环首先检查条件是否为 true，如果为 true，它将执行语句。<br>一下， 而循环在检查条件之前执行语句。如果条件为真， 它会再次执行语句。而循环将执行语句至少一次。
7	0	[1]	无答案
7	5	[28]	A 做...while 循环将始终执行至少一次，则一<br><br>，具体取决于条件。
7	5	[15]	while 循环是预检查（它会在 while 块内执行代码之前检查条件语句）<br><br>当循环是后检查时检查（它检查条件后块执行，它至少运行一次，无论条件语句是什么）
7	5	[14]	）） 一段时间和做...而声明？<br>执行，而构造由代码块和条件组成。首先，执行块中的代码，然后评估条件，直到证明为 false。While 循环之间的区别在于，它在执行块中的代码之前测试条件。<br>
8	2	[6]	对我们来说，它通常是一个集，获取，和显示Messge或其他消息，告诉你什么属性类有，但不显示其实现。您可以在自己的类定义中包含任何您想要的内容。
8	4	[5]	该类的属性。也它是否是子类。也不管是公私还是受保护。
8	5	[8]	告诉编译器哪些数据成员和成员函数属于类的信息。
8	5	[3]	由于类是用户定义的，因此声明的正文可以包含成员，可以是数据或函数声明，也可以是访问指定器。 说明符的示例将是公共的、私有的和受保护的。 有关键字类，类正文用括号 （+） 括起来。
8	2	[4]	对象和数据。
8	3	[9]	它是特定的类名，仅包括该类定义的信息...实现细节...等。
8	5	[22]	数据成员和成员函数。
8	5	[23]	类定义通常包含函数及其数据成员
8	5	[2]	数据成员和成员函数
8	3.5	[29]	成员函数
8	5	[31]	属于该类的成员函数和数据成员。
8	4.5	[12]	公共和私有区域，包括类中使用的函数和变量
8	3.5	[21]	关键字类后跟类名，内部声明类的公有和私有声明
8	3	[13]	类定义通常包括函数定义。
8	5	[11]	它以类开头，后跟类名，然后通常包含任何类的定义中，包括构造函数、数据成员和描述类的成员函数。
8	4.5	[17]	数据和方法
8	4.5	[7]	该类可访问的构造函数、函数和变量，可能还可访问其他类，具体取决于它们如何完成。
8	5	[10]	成员函数和数据成员。
8	2.5	[27]	公共部分和私有部分，必须有一个分号来设置结束
8	5	[25]	成员乐趣和数据成员
8	5	[20]	数据成员和成员功能
8	5	[18]	数据成员和成员函数
8	3.5	[19]	类名称及其公共数据类型，如构造函数、方法、函数。
8	4.5	[30]	一个构造函数和几个数据成员，以及至少一个公共数据成员或方法
8	2	[16]	类名， 两个卷曲的婚前， 公共和私人
8	5	[26]	数据成员和成员函数
8	4.5	[1]	数据和功能
8	5	[28]	属于类的函数和数据成员
8	5	[15]	类变量，类的函数定义
8	4.5	[14]	类是数据结构的扩展概念，它同时保存数据和正在执行的函数
9	3	[6]	数据成员是特定类的数据组件。 成员函数是类的功能组件。
9	2.5	[5]	字段变量是声明为类成员的变量。局部变量是声明方法的局部变量。
9	4.5	[8]	数据成员在类内声明，但在任何成员函数之外。与局部变量不同，类的每个对象都保留存储在内存中的数据成员自己的副本。
9	4.5	[3]	数据成员是表示类定义中属性的变量。 在函数体中声明的局部变量不能在该函数体之外使用。 当函数终止时，其局部变量的值将丢失。
9	5	[4]	不能在声明本地变量的函数之外访问局部变量。数据成员通常是私有的。声明私有的函数的变量只能对声明它们的类的成员函数进行访问。
9	4.5	[9]	数据成员是存储特定C++的类或结构的一部分...成员函数中的局部变量仅在该函数内可用，可用于派生所需的结果。
9	3.5	[22]	只能在其声明范围内访问局部变量。
9	4.5	[23]	数据成员是函数的属性，可以在函数外部使用。<br>本地变量不能在函数外部使用，并且函数终止后该值将丢失。
9	4	[2]	数据成员是类的永久属性，当成员函数的范围结束时，成员函数内的局部变量将丢失。
9	4	[29]	数据成员在类定义中声明，但在类的成员函数定义的实体之外。局部变量在函数定义的正文中声明
9	4.5	[31]	数据成员是全局可访问的，而局部变量只能在成员函数内访问。
9	5	[12]	成员函数中的变量只能在成员内部访问，并且可以通过程序访问数据成员。
9	4.5	[21]	局部变量仅在其声明范围内使用
9	2	[13]	数据成员是描述成员函数中实例化的所有对象的更通用的术语。 局部变量中的"局部"更是指变量的范围，变量可能位于从控件结构到类的任何东西中。 其作用域在成员函数中的局部变量与成员函数的数据成员相同。
9	3.5	[11]	数据成员只要运行，就永久存在于该程序的内存中。<br><br>成员函数内的局部变量是临时变量，仅用于在函数中操作，只要函数运行，就存在。
9	5	[17]	局部变量只能在函数内使用，其中作为数据成员可以设置为公共访问，并可用于整个
9	4.5	[7]	局部变量在退出代码块后将丢失，而数据成员则不丢失。
9	4.5	[10]	每个成员函数都可以访问和修改数据成员。<br>一个局部变量只能在从声明行到下一个关闭之前从内存丢失。
9	5	[27]	数据成员可供类中的所有函数访问，其中局部变量仅对成员函数可用，并且函数关闭时值丢失
9	4.5	[25]	数据成员是在类定义内声明的变量，但在类成员函数的实体之外。局部变量只能在函数声明中使用。
9	4	[20]	可以在类外部访问数据成员，而本地变量不能。
9	5	[18]	局部变量不能在该函数体之外使用。当函数终止时，其局部变量的值将丢失。其中作为数据成员是类定义中的变量，它们存在于对象整个生命周期中。<br>
9	2	[19]	成员函数中的局部变量必须为静态变量。数据成员可以自由更改其值。
9	5	[30]	局部变量仅在定义它的函数中可用，而数据成员可用于其类中的任何方法
9	5	[16]	在函数定义的主体中声明的变量不能在函数之外使用。<br><br>该类的成员函数才能访问数据成员。
9	4.5	[26]	数据<br><br>本地变量在函数定义中声明™的正文<br>它们不能在该功能体之外使用。<br>函数终止时，其局部变量的值将丢失。<br><br><br>
9	4.5	[1]	局部变量仅在函数中可用。
9	4.5	[28]	本地变量仅在成员函数内访问，而<br><br>整个类中可以访问数据成员
9	5	[15]	数据成员在类中的任意位置都可以访问，而成员函数中的 i 局部变量仅在该特定函数中可访问，并在函数退出后释放。
9	4	[14]	数据成员封装在类或对象中，它是静态的，可以由该类的所有实例共享。<br>然而，局部变量只从声明它的函数或块使用，而不是整个类。
10	2.5	[6]	构造函数初始化类的对象。 类的函数执行一项任务，如显示一行文本或执行某种数学运算。
10	3	[5]	所有构造函数都是函数，但并非所有函数都是构造函数。此外，函数可以具有几乎无限的用途，而构造函数始终创建您所使用任何类的实例。您可以更改构造函数做某事，但更改它所做工作。使用函数，您不仅可以更改如何，还可以更改什么。
10	5	[8]	与常规函数不同，构造函数仅在创建对象时™对象的数据。构造函数还必须与 类同名，并且不能返回任何值。<br>
10	4.5	[3]	构造函数通常用于实例化数据成员和分配资源，例如内存、文件等。 此外，构造函数不能返回值。 函数是可能全局定义的操作。
10	4	[4]	构造函数不能返回值，因此不能指定返回类型。通常，构造函数声明为公共。
10	3	[9]	构造函数是启动类的新实例的方法。（例如：员工员工 1（参数）启动类型为"员工"的对象的新实例）。函数只是一个模块，它位于程序中，可以完成其所需的单个任务。
10	3.5	[22]	每当创建该类的新对象时，都会调用构造函数。
10	4	[23]	构造函数不返回任何日期，并且没有返回类型。<br><br>功能可以返回日期，或者不返回数据可以具有返回类型。
10	4	[2]	每当创建类的实例时，都会自动调用构造函数，用户必须显式调用函数。
10	4	[29]	构造函数不能返回值，因此它们不能像函数那样指定返回类型。
10	3.5	[31]	构造函数是用于在创建对象数据时初始化对象的函数。
10	2.5	[12]	构造函数初始化所有内容，以便不留空或使用随机 variouble，并且函数使用数据修改这些变量。
10	3.5	[21]	构造函数在其实例化执行时初始化值。它提供默认值。
10	4	[13]	构造函数在实例化对象时设置变量的默认值，而函数允许与该对象交互。
10	3	[11]	构造函数用于创建可用于程序主函数的对象。 这可能与它一起执行代码，也可能不执行代码。<br><br>一个函数是一组代码，在调用时执行，但不会创建新对象。
10	4	[17]	构造函数初始化数据成员，但函数实际执行任务。构造函数也不能返回值。
10	3.5	[7]	构造函数不需要类型，它用于初始化变量。
10	4	[10]	构造函数没有返回类型。
10	3	[27]	构造函数将类对象创建到内存中，其中函数对该对象执行操作
10	4	[25]	构造函数不能返回值
10	2.5	[20]	构造函数初始化值，函数通常执行某种操作。
10	5	[18]	构造函数是用于在创建对象数据时初始化对象的函数。在创建对象时，将隐式调用它，并且必须使用与类相同的名称进行定义。构造函数也不能返回函数可以返回的值。
10	4	[19]	构造函数用于创建类的实例，并且与该类具有相同的名称。函数不能与类具有相同的名称并计算数据。
10	3	[30]	构造函数是初始化类实例的函数，函数执行为它编写的任何任务
10	4	[16]	构造函数不能返回值，甚至不能 void，但函数获取返回值。
10	5	[26]	构造函数不能返回值，它甚至不无效。它用于在创建对象时初始化对象的数据。<br>，创建函数来执行特定任务，并且它可以返回值。
10	2.5	[1]	构造函数初始化对象。函数是对象的一部分。
10	2.5	[28]	构造函数初始化数据，然后用于计算<br><br>函数
10	3.5	[15]	创建类时调用构造函数，可随时调用函数。
10	4	[14]	构造函数是在创建对象时调用的特殊语句块，在静态声明或堆栈上构造对象时调用该语句块。但是，函数是较大程序中代码的一部分，它执行特定任务，独立于代码的其余部分。
