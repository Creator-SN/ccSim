11	5	[6]	当我们不在类文件中定义一个构造函数时，编译器将创建一个默认构造函数
11	3.5	[5]	编译期间
11	5	[8]	当类未显式包含构造函数时。
11	3	[3]	当不设置参数时，即使用默认构造函数时。
11	5	[4]	当类未显式包含构造函数时。
11	1.5	[9]	当没有通过参数时。
11	5	[22]	当特定类还没有一个时
11	3.5	[23]	当它的程序编译
11	5	[2]	当构造函数未由类的程序员提供时
11	5	[29]	在任何未显式包含构造函数的类中。
11	1	[31]	在代码的主要功能之前。
11	5	[12]	每当你不指定你自己的
11	5	[21]	当提供非
11	5	[13]	C++构造函数将创建默认构造函数，当没有其他构造函数存在时。
11	5	[11]	当构造函数的类中未指定构造函数时，但该类在程序中实例化。
11	5	[17]	当不需要构造函数时，将声明一个无参数的默认构造函数。
11	5	[7]	编译器会自动为您创建此函数，除非您专门创建一个。
11	5	[10]	在任何未显式包含构造函数的类中。
11	5	[27]	当不存在用户定义的构造函数时
11	5	[25]	如果类未显式包含构造函数，编译器将创建一个构造函数。
11	5	[20]	当您不提供自己的构造函数时。
11	5	[18]	当类未显式包含构造函数时。
11	5	[19]	C++在编译期间创建默认构造函数（如果未提供）。
11	5	[30]	当类未显式包含构造函数时
11	5	[16]	当类未明确包含 consructor 时，编译器将提供一个。
11	5	[26]	当程序员没有明确包括构造函数时
11	5	[1]	当一个人没有明确说明时。
11	5	[28]	当一个类未显式包含时<br>
11	5	[15]	当您不指定任何构造函数时。
11	5	[14]	在运行一个复杂函数的一开始，在C++，如果用户没有提供其他构造函数，它为类生成自己的默认构造函数
12	0	[6]	每节课只有一个。
12	5	[5]	只要它们具有不同的参数，就尽可能多。
12	5	[8]	类中的构造函数数没有限制，因为与函数一样，构造函数可以重载。
12	1.5	[3]	这取决于正在定义的类类型。 通常，每个对象都有一个构造函数调用。
12	5	[4]	在C++中，可以重载构造函数，因为类可以有多个构造函数，每个构造函数具有不同的参数。
12	0	[9]	1
12	5	[22]	任何你想要的号码
12	0	[23]	一
12	5	[2]	默认情况下只有一个， 但它们可以重载以创建尽可能多的构造函数。
12	5	[29]	尽可能多的你想要的
12	5	[31]	尽可能多的，你想，具有不同的参数。
12	5	[12]	无限
12	5	[21]	尽可能多的， 你需要
12	5	[13]	根据需要使用，具体取决于在实例化对象时希望直接修改或保留为默认值的变量数。
12	5	[11]	可以通过重载为任何给定类创建大量构造函数。 当创建两个具有不同类型或数量的参数的构造函数时，它们被重载，C++ 可以根据传递/返回的变量类型识别要使用的构造函数。
12	2.5	[17]	这取决于对象的数量。每个对象都应该有一个构造函数。
12	5	[7]	理论上是无限的，只要它们是由程序员定义的。
12	5	[10]	根据需要提供。
12	5	[27]	所需的/需要的要多
12	4.5	[25]	几个
12	0	[20]	一
12	0	[18]	一
12	5	[19]	只要签名不同，就可以有无限构造函数。
12	1.5	[30]	这取决于类中的数据成员数
12	0	[16]	一
12	5	[26]	您可以根据需要重载构造函数
12	5	[1]	程序员想要创建的人很多。
12	0	[28]	一
12	5	[15]	只要它们都有一个唯一的参数列表， 只要它们都有一个唯一的参数列表
12	5	[14]	用户决定使用的。
13	4	[6]	函数定义不需要在其括号内传递任何其他信息<br>执行。虽然定义原型需要传递多个参数才能完成其<br>任务。
13	2.5	[5]	函数原型是程序员声明他/她使用的是 main （这就像声明一个变量，程序员知道他/她将来将使用，但还没有说他们将在哪里使用它，或如何使用它。这是回答谁的问题，它给函数一个名称和字符。函数原型，按常用做法放置在程序的开头后，#includes主（） 之前。<br>函数定义是函数的内脏。这是程序员决定函数要做什么并告诉它如何执行它的地方。它包含任何信息，并执行操作。它的工作原理有点像大脑，大脑接受输入，并基于输入执行某种方式产生输出。函数定义位于主 （ ） 和任何其他函数之外。函数是它自己的实体，应该这样考虑。
13	5	[8]	函数原型告诉编译器函数名称、返回类型以及参数的数量和类型，而不显示函数定义中包含的实现。
13	3	[3]	函数原型是一个声明。 函数定义（带多个参数）通常需要多条信息。执行他们的任务。
13	5	[4]	函数原型是函数的声明，它告诉编译器函数的名称、其返回类型及其参数的类型。
13	4.5	[9]	原型仅显示返回类型和必要参数。该定义包括这些参数的名称，并定义对象实际能够执行哪些操作。
13	4.5	[22]	原型仅告诉用户哪些数据类型进入函数以及返回什么类型。
13	4.5	[23]	函数原型位于 .h 文件中，仅包含访问函数名称和参数类型。<br><br>功能定义包含函数执行其活动的代码。
13	4	[2]	函数原型用于将编译器引用到稍后将定义的函数，函数定义是实际函数本身，包含返回类型、参数等。
13	4.5	[29]	函数原型描述类的公共接口，而不显示类的成员函数实现
13	2	[31]	函数定义就是这个定义。原型是编译器用来检查对函数的调用是否正确的。
13	3	[12]	原型不包含函数具有在程序中执行的所有代码的任何实际代码。
13	3	[21]	原型声明将在程序中使用的和定义
13	5	[13]	函数原型按特定顺序排列函数预期接收的名称、返回类型以及参数的数量和类型。 函数原型的详细信息在函数定义中。
13	5	[11]	函数定义是定义放置在 [ 括号中确定该函数操作的函数的代码。<br><br>一个函数原型显示函数的公共接口，而不公开实现。 它显示参数的名称、返回类型和类型。
13	3.5	[17]	函数原型只是现有函数的声明，不能用作实际函数。必须使用 内部定义创建函数，以告诉编译器函数的作用。
13	4.5	[7]	原型创建一个框架来调用函数定义。虽然函数定义是函数实际编程并创建为最终产品的地方。
13	4.5	[10]	函数原型描述类的公共接口，而不提供函数的工作原理。<br>函数定义包含函数的内部工作。
13	3.5	[27]	原型在编译前状态该类中的所有函数，其中定义实际包含函数的源
13	5	[25]	函数原型告诉编译器函数名称、其返回类型及其参数的类型，其中函数定义实际实现成员函数。
13	4	[20]	函数原型仅指定参数。 函数定义包括参数和代码体。
13	4.5	[18]	函数原型描述类的公共接口
13	4.5	[19]	原型仅声明名称、返回类型和输入类型。<br>定义还定义了范围、变量、过程和返回函数
13	4	[30]	函数原型简单地声明函数参数，函数定义包括任何必要的变量和函数的实际代码
13	3.5	[16]	functgion 原型是函数的声明，而函数定义指定函数的作用
13	5	[26]	在函数原型中，包括返回类型、函数的名称及其参数（如果需要）。<br><br>函数定义中编写函数将执行哪些项代码。
13	4.5	[1]	函数定义包含函数工作的所有代码。函数原型只显示输出、输入和函数名称。
13	4.5	[28]	函数原型描述类的公共接口，而不<br><br>类的成员函数实现，函数定义显示<br><br>实现
13	5	[15]	函数原型仅命名函数、其返回类型和参数列表，而定义定义上述以及函数实际操作的功能。
13	4.5	[14]	函数原型描述了一个类接口，而不斥责里面的任何，因为函数定义不能这样做。<br>
14	4.5	[6]	标头文件的作用列出了类在隐藏其函数的内部工作时可以执行的所有函数<br>
14	3	[5]	头文件的主要作用是它用于在各种文件之间共享信息。
14	3.5	[8]	标头文件分隔定义类的文件，并允许编译器在其他地方使用时识别类。
14	0	[3]	不
14	3.5	[4]	标头文件由"可重用"源代码组成，如文件中的类，按约定具有 .h 文件名扩展名。这与包含"源代码"的 .cpp 文件不同。
14	4.5	[9]	提供有关库内容的信息。它包括类的定义、函数的声明、数据类型和常量。
14	4.5	[22]	头文件向用户显示哪些类型进入和从函数中出来，但不允许用户操作函数的实际代码。
14	3.5	[23]	标题文件声明类成员函数。
14	4	[2]	标头文件允许将声明和实现分离为单独的文件。
14	1.5	[29]	头文件有权访问标准库C++类等类工作。
14	2.5	[31]	[结构] 编译器如何与库和用户编写的组件进行接口。
14	3	[12]	创建一个 comon 区域以包含可重用函数。
14	3	[21]	声明类中使用的函数
14	1.5	[13]	#include"hat.h"允许使用帽子容器，所以从帽子里拉名字的行为。 帽子的头文件包括用于存储和检索其内容的功能，主要是 put（）、窥视（）和拉（）。
14	4	[11]	将可重用的内容或模块与可用于不同程序的实际源代码文件分开。
14	5	[17]	头文件是用于存储原型函数和数据成员列表的文件。
14	3.5	[7]	标头文件是源文件之间的交叉通信方法，可帮助限制每个程序的大小。没有头文件，程序将是一个大的代码块，因此相当难以调试和遍历。
14	3	[10]	它包含可重用的源代码供其他类使用。
14	3.5	[27]	将源代码与主函数分离，允许在程序中包含方法/类，而无需直接编码。允许重新可用性。
14	2.5	[25]	标题文件在程序程序器可以使用的文件中具有可重用的源代码。
14	3.5	[20]	隐藏类的定义和详细信息。 也为了帮助主文件的可C++。
14	3.5	[18]	允许编译器在其他地方使用时识别类。
14	4	[19]	标头文件声明类、其数据和通过该类可用的函数。
14	3	[30]	头文件包含可用于多个文件的代码
14	3	[16]	允许编译器在其他地方使用时识别类
14	3.5	[26]	允许编译器在其他地方使用时识别类<br>
14	3	[1]	重新提升功能
14	3	[28]	类定义放在这里
14	4.5	[15]	标头文件通常包含类和/或函数原型。
14	1	[14]	包含库C++的所有标准代码，即字符串
15	4.5	[6]	它包括程序的名称，它可以采取的参数的类型。它还应包括函数作用的简要说明。
15	3	[5]	它包括有关函数的特定信息，如输入和输出变量类型以及每种变量类型中有多少个。
15	5	[8]	函数签名包括函数的名称及其参数的类型。
15	4.5	[3]	函数签名由函数原型组成。 这将告诉您有关函数、其名称、参数、函数位于什么范围和其他杂项信息的一般信息。
15	5	[4]	它包括函数的名称及其参数的类型。
15	4.5	[24]	名称、参数、范围和其他一般功能信息
15	5	[9]	它包括一个函数名称和参数列表。不包括返回类型。函数签名必须不同。
15	3	[22]	输入参数和返回类型
15	5	[23]	函数原型的部分具有函数名称和参数，但没有返回类型。
15	5	[2]	函数的名称及其参数的类型
15	5	[29]	函数的名称及其参数的类型。
15	5	[31]	包括函数的名称及其参数的类型。
15	5	[12]	函数及其参数的数据类型的标识，具有名称和数据类型变量
15	3	[21]	返回类型和输入参数
15	5	[13]	函数签名包括方法名称和输入类型。
15	5	[11]	函数签名包括函数的名称和参数类型，但不包括返回类型。<br><br>
15	2	[17]	签名可以包括结果类型和引发的错误。
15	5	[7]	函数名称和输入参数
15	5	[10]	函数的名称及其参数的类型。<br>包括参数显示的数字、类型和顺序。
15	5	[27]	函数的名称及其参数的类型
15	5	[25]	函数签名包括函数的名称及其参数的类型
15	3	[20]	函数签名包括函数的返回类型、参数和分号。
15	5	[18]	函数的名称及其参数的类型
15	5	[19]	函数的名称和参数
15	5	[30]	函数的名称及其参数的类型。
15	5	[16]	函数原型包含函数名称及其参数类型的部分
15	5	[26]	函数的名称及其参数
15	5	[1]	函数名称和参数
15	5	[28]	函数名称和参数类型
15	3	[15]	函数的返回类型和参数列表
15	5	[14]	它包括函数的名称及其参数的类型。它不指定函数返回类型。同一作用域中的函数必须具有取消qiue 签名。
16	5	[6]	源代码文件中任何跟随其减速的函数都允许访问变量。 此外，全局范围变量在整个程序执行过程中重新训练其值。
16	2.5	[5]	任何用户都可以在任何地方访问C++文件。
16	5	[8]	全局变量具有文件范围。
16	2.5	[3]	全局变量的范围通过将变量声明置于任何类或函数定义之外来创建。 全局变量在整个程序执行过程中保留其值，并且它们可以由遵循其声明或源文件中定义的任何函数引用。
16	5	[4]	全局变量是在整个程序执行过程中保留其值的标识符。它有文件范围。
16	4	[24]	只要包含适当的 .h 文件，则全局变量可用于任何函数
16	5	[9]	程序的任何部分都可以访问它们。它可以由遵循源文件中的声明或定义的任何函数引用。
16	3	[22]	可由具有 和 对象的任何类在其中具有 和 对象的
16	5	[23]	全局变量具有文件范围。 变量是通过文件知道的所有函数
16	4.5	[2]	整个程序
16	5	[29]	它们在放置在函数外部时具有文件范围。
16	5	[31]	文件范围。
16	4.5	[12]	它们可用于整个程序
16	3	[21]	全局变量可以 b 由变量类中的任何类 wit 访问对象
16	5	[13]	全局变量的范围在文件级别。
16	5	[11]	全局变量都有文件范围。
16	4.5	[17]	程序内的所有函数均可访问它
16	4.5	[7]	变量可在程序中的任意位置访问，只要它们是公共的。
16	5	[10]	它们可以由源文件中声明或定义后的任何函数引用。
16	4.5	[27]	全球，在程序的任何地方。
16	5	[25]	全局变量具有文件范围
16	4.5	[20]	整个程序。
16	4.5	[18]	在整个程序执行
16	4.5	[19]	如果变量声明为全局变量，则任何函数或类都可以使用该变量。
16	5	[30]	整个程序或文件。
16	4.5	[16]	通过程序
16	4.5	[26]	整个代码
16	5	[1]	文件范围
16	5	[28]	可由源文件中遵循其声明或定义的任何函数引用
16	4.5	[15]	全局变量具有程序范围（可在程序中的任意位置访问）
16	4.5	[14]	通过整个脚本存在的变量。它们的值可以随时在代码和 fucnction 中更改。
17	4.5	[6]	它在该位置扩展函数的定义。 调用函数后，您可以尽可能多次地使用它。 编译器只是扩展函数。
17	4.5	[5]	当编译器内联扩展函数调用时，函数的代码将插入到调用方的代码流中（在概念上类似于使用宏#define情况）。这可以从其他一些情况来提高性能，因为优化器可以在程序上将调用的代码集成为"将被调用的代码优化到调用方中。<br><br>
17	5	[8]	inline 关键字建议编译器将函数的代码复制到位，以避免函数调用;但是，编译器可以而且通常忽略除了最小函数外的所有函数的内联限定符。
17	3	[3]	编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。
17	5	[4]	将限定符内联放在函数的返回类型之前，在函数定义"建议"编译器生成函数代码的副本，以避免函数调用。
17	2	[24]	在标题中或 int main（） 之前声明内联函数。然后，您可以在主程序中随时快速轻松地调用该函数。
17	4	[9]	它扩展了一个小功能...使代码更长，但也使代码运行得更快。
17	3.5	[22]	函数不与其他函数一样被视为单独的单元
17	5	[23]	程序编译时，将复制函数，避免函数调用。
17	5	[2]	它将该函数调用的所有实例替换为内联代码本身，从而生成更长但更快的程序。
17	3	[29]	编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。
17	3	[31]	忽略内联限定符，通常对除了最小函数的所有函数都这样做。
17	4.5	[12]	如果函数足够小，它将扩展它，但它将运行得更快，因为它将避免对函数进行这么多调用。
17	2	[21]	它把它们当作相同的功能
17	5	[13]	内联函数将就地复制，而不是被引用。
17	5	[11]	对于内联函数，编译器将创建函数代码的副本，因此它不必进行函数调用并添加到函数调用堆栈。
17	5	[17]	它生成函数的编码副本，从而消除了调用函数
17	0	[7]	未回答
17	4.5	[10]	它通过在程序中插入函数的代码来生成函数代码的副本。
17	5	[27]	告诉编译器将函数的代码副本用于位，以避免函数调用。 它通常忽略它，除了最小的函数。
17	2	[25]	编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。
17	4.5	[20]	函数代码的多个副本入到程序中，使其变大。
17	2.5	[18]	编译器忽略内联限定符
17	3.5	[19]	如果需要，它将生成函数的副本。
17	5	[30]	该符合符包括内联函数的副本，而不是进行函数调用，但通常只使用非常小的函数。
17	5	[16]	编译器生成函数代码的副本（如果适用），以避免函数调用
17	5	[26]	而不是每次调用函数时调用函数，编译器将用函数体的副本替换函数调用
17	4	[1]	将函数扩展到程序中
17	5	[28]	它生成函数代码的副本， 以避免函数调用
17	5	[15]	函数调用将被内联函数中定义的代码替换
17	4.5	[14]	当编译器内联扩展函数调用时，函数的代码将插入到调用方的代码流中（在概念上类似于使用宏#define情况）。这可以从其他一些情况来提高性能，因为优化器可以在程序上将调用的代码集成为"将被调用的代码优化到调用方中。
18	5	[6]	总的来说，程序具有更好的性能（意味着它更快），因为它不必复制大量数据。
18	4.5	[5]	因为您无法更改原始和通过引用限制传递程序所需的内存。
18	5	[8]	通过引用传递可以消除复制大量数据的按值传递开销。
18	5	[3]	将引用（而不是大型对象）传递给函数通常效率更高。这允许编译器传递对象的地址，同时维护用于访问对象的语法。
18	5	[4]	由于性能原因，通过引用传递是很好的，因为它可以消除复制大量数据的价值开销。
18	3	[24]	不会更改传递的变量的原始值。
18	4.5	[9]	不必复制东西。
18	5	[22]	不使用 unessesary 内存空间在函数之间复制变量
18	5	[23]	它支持了复制大量数据所需的需求
18	3.5	[2]	函数可以更改直接通过引用传递的变量中存储的数据。
18	3.5	[29]	为调用函数提供了访问和修改调用方和™参数数据的能力。
18	3.5	[31]	使调用函数能够直接访问和修改调用方™的参数数据。
18	3	[12]	它效率更高，它更改变量不是函数内部联机，而是外部，以便新值可以在其他位置使用。
18	5	[21]	你不做另一个副本和浪费内存
18	5	[13]	通过引用传递消除了大量数据的复制，通常具有按值传递的数据。
18	5	[11]	如果函数的参数大小较大，则计算时间和内存空间不会浪费复制参数并传递到函数。 通过引用传递也给出了称为函数直接读取编辑参数的权限。
18	3.5	[17]	直接提供对调用方数据的访问权限，还允许修改数据。
18	3.5	[7]	较低的开销，并直接修改变量。
18	3	[10]	引用的原始变量可以直接由被调用的函数修改。
18	3.5	[27]	提供直接访问和修改调用方参数数据的函数功能
18	3	[25]	使调用函数能够直接访问和修改调用方的参数数据。
18	3.5	[20]	比通过值传递的开销少，尤其是在使用大数时。
18	5	[18]	无需复制整个数据点即可传递大型数据项，从而减少执行时间和所需的内存空间不足<br>
18	4	[19]	可以直接修改数据，而不是复制数据。利用大量数据缩短执行时间。
18	3.5	[30]	函数可以直接修改通过引用传递的参数。
18	5	[16]	它直接提供访问和修改调用方的参数数据。它消除了复制大量数据的价值开销
18	4	[26]	它需要更少的内存， 因此它会使程序更快
18	3.5	[1]	您可以修改直接引用的变量。
18	3.5	[28]	如果通过引用传递，可以修改值，而不是在无法更改值的通过值传递值时修改值
18	5	[15]	仅将内存地址发送到函数，因此无需复制发送的对象。它使函数运行得更快，并节省内存。
18	3	[14]	当引用函数或子例程时，实际参数与虚拟参数关联。在过程引用中，实际参数列表标识列表中提供的实际参数与子程序虚拟参数之间的对应关系
19	5	[6]	编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。
19	3	[5]	它们由编译器根据用于重载函数之一的条件/输入进行区分。
19	5	[8]	编译器通过重载函数的签名来区分重载函数。它将每个函数标识符及其参数的数量和类型编码，以生成类型安全链接，从而确保调用正确的重载函数。
19	5	[3]	重载函数通过其签名、名称修饰或名称修饰进行区分，并且类型安全链接可确保调用适当的重载函数，并且参数的类型符合参数的 tpes。
19	5	[4]	编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。
19	3	[24]	按其类型（int、字符等）
19	5	[9]	它根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。
19	3	[22]	重载函数必须具有相同的返回类型，但输入参数不同
19	5	[23]	它检查每个函数上参数的名称、类型和顺序。
19	5	[2]	唯一函数签名
19	5	[29]	基于函数调用中参数的数量、类型和顺序。
19	5	[31]	编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。
19	0	[12]	未回答
19	3	[21]	它们必须具有相同的返回类型， 但输入参数不同
19	4.5	[13]	重载函数按其参数进行区分。
19	5	[11]	编译器从函数调用中参数的数量、类型和顺序中选择正确的函数来执行。
19	3	[17]	它创建一组候选函数， 然后创建一组可行的函数
19	5	[7]	其功能签名。
19	5	[10]	其参数的数量和类型。
19	5	[27]	由其函数签名
19	3.5	[25]	它们具有相同的名称，只是不同的参数。
19	5	[20]	它们因函数调用中的参数数、类型和顺序而有所不同。
19	5	[18]	它查看函数调用中参数的数量、类型和顺序<br>
19	5	[19]	编译器通过签名区分重载函数。
19	5	[30]	按其参数的数量、类型和顺序
19	5	[16]	编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。
19	4.5	[26]	百度计
19	5	[1]	按数字以及参数的类型和顺序。
19	5	[28]	按参数的数量和类型
19	4	[15]	按其签名（返回类型、参数列表）
19	3	[14]	重载函数只是 invovles 在类中使用相同的名称。重载基于对象存在的上下文为对象提供不同含义的概念。重载是多态性之一，这也是编程中的一个功能。
20	5	[6]	一个基本情况，这是问题最简单的情况，以便函数将导致它，如果这不会发生，那么它最终将成为一个无限循环。以及知道何时终止的条件。
20	2.5	[5]	设计不良的阿尔戈里西姆斯。使用递归解决非递归问题。
20	5	[8]	当省略基大小写或重复步骤写入不正确，以便永远不会在基大小写上收敛时，可能会发生无限递归。
20	5	[3]	如果未满足条件，无限递归是无限循环。 省略基大小写，或错误地写入递归步骤，以便它不在基大小写上收敛，这会导致"无限期"递归，最终耗尽内存。
20	5	[4]	省略基大小写或错误地写入递归步骤，以便它不在基大小写上收敛会导致无限递归。
20	4	[24]	没有返回基值的基大小写。
20	5	[9]	不正确或缺少基本大小写。必须减小到基本情况。函数每次运行时必须变得更简单（收敛到基本大小写）。
20	4.5	[22]	没有基本<br>值没有变化。
20	5	[23]	如果在每个递归调用中，问题不会减少，或者它不会减小到基本情况，则可能导致无限递归。
20	5	[2]	省略基本大小写或错误地调用递归步骤。
20	4.5	[29]	递归问题不能减少以达到基本情况。
20	5	[31]	缺少定义基案例，或错误地写入递归步骤，以便它不会在基案例上收敛
20	4	[12]	没有适当的案例离开递归
20	5	[21]	无基例，或递归调用不收敛到基例
20	5	[13]	没有基例，或未正确写入的递归步骤不收敛在基例上将导致无限递归。
20	5	[11]	如果递归函数永远不会达到或成功定义基本大小写，它将永远递归。<br><br>发生这种情况的方式有很多种，例如函数不会向基例中推进，或者函数编码错误，甚至不包含基例。
20	5	[17]	<br>创建基本大小写，或在永远不会满足基本大小写的情况下。
20	3.5	[7]	处理不当的情况，因此并非所有可能的值都能够处理。
20	4.5	[10]	没有基本情况。<br>递归步骤不会减少每次递归调用期间的问题。
20	3.5	[27]	无基例，如不包括再次调用函数的单个返回。 静态值结束。
20	5	[25]	省略基大小写，或错误地写入递归步骤，以便它未到达基大小写可能会导致无限递归。
20	5	[20]	省略基例或写入递归调用，以便它不会在基大小写上收敛。
20	5	[18]	省略基大小写，或错误地写入递归步骤，以便它不会在基大小写上收敛
20	4.5	[19]	如果未定义基大小写，或者调用没有变化，可能会发生无限递归。
20	5	[30]	没有基案例，或构建不在基案例中收敛的递归过程。
20	5	[16]	省略基本大小写，或不正确地写入递归步骤
20	5	[26]	没有基本<br>， 如果程序马尔没有将基本大小写定义为最简单的情况， 并且永远不会到达
20	5	[1]	没有容易到达的基本案例，也没有基本案例
20	5	[28]	函数绝不允许到达"基本案例"
20	5	[15]	它没有基本案例， 或基本案例永远不会满足
20	3	[14]	递归是指函数调用自己的情况。这些类型的函数称为递归函数。话虽如此， 无限递归发生时， 函数的设计方式， 以永远调用它自我， 而不停止可能的原因
21	5	[6]	两者都涉及受控的重复结构，并且它们都有终止测试。 此外，他们两个可以永远循环。
21	2	[5]	如前所述，递归可用于处理迭代操作。递归用于计算答案可以在与自身相关的函数中描述。
21	5	[8]	迭代和递归都基于控制语句，并涉及重复。它们也可以无限期地发生。
21	5	[3]	两者都基于一个控制语句<br> - 迭代重复结构<br> - 递归选择结构<br><br>两者都涉及重复<br> - 迭代显式使用重复结构<br> - 递归重复函数调用<br><br>两者都涉及终止测试<br> - 迭代-循环终止测试<br> - 递归 - 案例<br><br>两者都逐渐接近终止<br> -迭代修改计数器，直到循环终止测试失败<br> -递归-产生逐渐简单的问题版本<br><br>两者都可以无限期地发生<br> -迭代-如果循环-继续条件永远不会失败<br> -递归-如果递归步骤不简化问题
21	5	[4]	迭代和递归有许多相似之处：两者都基于控制语句、涉及重复、涉及终止测试、逐渐接近终止并可能发生无限。
21	5	[24]	两者都依赖于重复，都有一个基例，两者都可以变成无限循环。任何递归也可以通过迭代来解决。
21	4	[9]	两者将重复（循环），直到满足条件，并退出循环。两者都能够进入无限循环。
21	3	[22]	任何你能做的， 你可以做递归
21	4.5	[23]	两者都是重复的，并且都有结束测试。
21	3.5	[2]	写入不正确都会导致无限循环，两者都执行相同的任务一遍又一遍。
21	5	[29]	两者都基于控件语句。<br>两者都涉及重复。<br>两者都涉及终止测试。<br>两者逐渐接近终止。<br>两者都可以无限发生。<br><br>
21	5	[31]	两者都基于控制语句， 两者都涉及重复， 两者都涉及终止测试， 两者都逐渐接近终止， 两者都可以无限发生
21	0	[12]	未回答
21	3	[21]	任何你可以重复性地做， 你可以重复做
21	3.5	[13]	许多问题可以通过迭代和递归来解决，如果省略终止测试，则其中一个问题可能会进入无限执行状态。
21	5	[11]	迭代和递归都使用重复，并连续执行几个简单的操作和算法，直到它们达到一定的限制。 因此，两者都涉及终止测试以查找该限制，并且两者都缓慢地接近该终止限制。 两者都基于控制语句。 <br><br>如果编码错误，两者都可以永远继续，直到编译器或计算机锁定、关闭或停止操作。
21	5	[17]	既基于控制语句， 涉及重复， 也涉及循环内的终止测试
21	2	[7]	它们是重复相同任务的方法。
21	5	[10]	两者都涉及终止测试。 <br>他们使用控制语句和重新声明来解决问题。<br>他们也可以导致一个无限的循环。
21	5	[27]	基于控制语句，涉及重复，涉及终止测试。
21	5	[25]	两者都是基于控件语句。两者都涉及重复。两者都涉及终止测试。两者都逐渐接近终止。两者都可以无限发生。
21	5	[20]	两者都基于控制语句，两者都涉及重托，都涉及终止测试，两者都逐渐接近终止，两者都可能发生在内特。
21	5	[18]	它们都基于控制语句， 都涉及重复， 都涉及终止案例， 两者都涉及终止案例， 两者都可以无限发生
21	5	[19]	他们都使用重复，控件或测试终止，两者都可以无限重复，如果定义不正确。
21	5	[30]	两者都基于控件语句;两者都逐渐接近终止终止结束与终止测试;两者都涉及重复，如果未满足终止要求，则两者都可以无限重复。
21	5	[16]	两者都基于控制语句，涉及重复，并涉及终止测试。两者都逐渐接近终止， 两者都可能发生无限
21	3.5	[26]	它们用于解决相同类型的问题。他们一遍又一次地执行一项任务，直到到达循环条件语句（在递归中称为基本大小写）。
21	5	[1]	基于控制语句; 涉及重复;涉及终端测试;两者都可能发生在<br>
21	5	[28]	重复，终止测试，最终终止，发生下
21	3	[15]	两者都需要有某种基本大小写来判断循环何时需要停止。
