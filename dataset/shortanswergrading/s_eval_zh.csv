4	5	[2]	主要
9	5	[18]	局部变量不能在该函数体之外使用。当函数终止时，其局部变量的值将丢失。其中作为数据成员是类定义中的变量，它们存在于对象整个生命周期中。<br>
20	4	[24]	没有返回基值的基大小写。
9	5	[17]	局部变量只能在函数内使用，其中作为数据成员可以设置为公共访问，并可用于整个
7	5	[23]	-WHILE 语句 - 条件检查是否有效，然后重复，直到凹凸不成天。<br><br>做...WHILE 语句 - 代码至少执行一次，然后检查为有效条件。 将继续<br>
5	5	[2]	包含特定类型数据的内存块
15	5	[27]	函数的名称及其参数的类型
20	5	[4]	省略基大小写或错误地写入递归步骤，以便它不在基大小写上收敛会导致无限递归。
13	4.5	[10]	函数原型描述类的公共接口，而不提供函数的工作原理。<br>函数定义包含函数的内部工作。
9	4.5	[1]	局部变量仅在函数中可用。
20	4.5	[22]	没有基本<br>值没有变化。
8	3.5	[19]	类名称及其公共数据类型，如构造函数、方法、函数。
21	3.5	[2]	写入不正确都会导致无限循环，两者都执行相同的任务一遍又一遍。
5	5	[11]	变量是计算机内存中可能发生变化的值，可由程序使用。 程序可以更改变量的值，并在以后调用它，或者直接对它采取行动。
16	4.5	[7]	变量可在程序中的任意位置访问，只要它们是公共的。
20	5	[3]	如果未满足条件，无限递归是无限循环。 省略基大小写，或错误地写入递归步骤，以便它不在基大小写上收敛，这会导致"无限期"递归，最终耗尽内存。
12	5	[10]	根据需要提供。
7	5	[19]	A 做...while 语句在检查条件之前将始终至少执行一次"do"代码。while 语句将始终首先检查条件。
15	5	[10]	函数的名称及其参数的类型。<br>包括参数显示的数字、类型和顺序。
8	5	[26]	数据成员和成员函数
20	5	[30]	没有基案例，或构建不在基案例中收敛的递归过程。
5	5	[22]	变量是计算机内存中可存储值以供程序使用的位置
17	2	[25]	编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。
4	5	[17]	在"主（）"功能
1	5	[3]	在规范阶段定义原型可刺激所需软件产品部分的行为。 这意味着，原型的作用是一个临时的解决方案，直到程序本身被完善，以广泛用于解决问题。
18	3.5	[29]	为调用函数提供了访问和修改调用方和™参数数据的能力。
19	3	[17]	它创建一组候选函数， 然后创建一组可行的函数
8	3.5	[29]	成员函数
5	5	[13]	变量是特定类型存储数据的内存地址，或者从数学角度来看，表示具有更改值的固定定义的符号。
4	5	[26]	他们承诺在主执行
20	5	[21]	无基例，或递归调用不收敛到基例
11	5	[2]	当构造函数未由类的程序员提供时
12	0	[6]	每节课只有一个。
17	5	[16]	编译器生成函数代码的副本（如果适用），以避免函数调用
3	5	[5]	这种类型的编程更加灵活，使得添加和修改程序更加容易。 它也是一种故障安全程序的类型，您可以检查每个单独的模块。 这消除了冗余代码，使程序更易于其他程序员阅读。 调试程序时，更容易跟踪模块中问题的根源，而不是 200 万行程序。
15	5	[8]	函数签名包括函数的名称及其参数的类型。
9	4.5	[3]	数据成员是表示类定义中属性的变量。 在函数体中声明的局部变量不能在该函数体之外使用。 当函数终止时，其局部变量的值将丢失。
3	4	[2]	可维修性和易用性
9	2	[13]	数据成员是描述成员函数中实例化的所有对象的更通用的术语。 局部变量中的"局部"更是指变量的范围，变量可能位于从控件结构到类的任何东西中。 其作用域在成员函数中的局部变量与成员函数的数据成员相同。
12	0	[23]	一
2	1.5	[13]	测试阶段对程序的最终版本有直接影响，因为它是软件修订的调试和最终完成。
18	5	[13]	通过引用传递消除了大量数据的复制，通常具有按值传递的数据。
12	1.5	[3]	这取决于正在定义的类类型。 通常，每个对象都有一个构造函数调用。
11	1	[31]	在代码的主要功能之前。
20	4.5	[29]	递归问题不能减少以达到基本情况。
21	5	[3]	两者都基于一个控制语句<br> - 迭代重复结构<br> - 递归选择结构<br><br>两者都涉及重复<br> - 迭代显式使用重复结构<br> - 递归重复函数调用<br><br>两者都涉及终止测试<br> - 迭代-循环终止测试<br> - 递归 - 案例<br><br>两者都逐渐接近终止<br> -迭代修改计数器，直到循环终止测试失败<br> -递归-产生逐渐简单的问题版本<br><br>两者都可以无限期地发生<br> -迭代-如果循环-继续条件永远不会失败<br> -递归-如果递归步骤不简化问题
2	5	[11]	直接：精炼，编码。 因为精炼就在测试阶段之前，编码就在测试阶段之后。<br><br>：生产、维护。 因为精炼发生在软件生命周期的最后两个阶段之前。
9	4.5	[7]	局部变量在退出代码块后将丢失，而数据成员则不丢失。
15	5	[19]	函数的名称和参数
20	5	[20]	省略基例或写入递归调用，以便它不会在基大小写上收敛。
14	1	[14]	包含库C++的所有标准代码，即字符串
1	3.5	[23]	-提供完成的程序应如何执行的示例或模型。<br>-为一些将遇到的挑战提供了远见卓识。<br>-提供机会对已完成的程序进行更改。
8	3	[13]	类定义通常包括函数定义。
1	2.5	[27]	在开发的早期阶段从用户获得早期反馈。 向用户展示程序将做什么/外观的第一个想法。 确保程序在密集编程开始前满足要求。
7	5	[2]	而语句将在执行循环（包括第一个循环）之前对语句进行计算，这意味着 while 循环不会始终执行。A 做...同时将运行计算语句后运行循环的循环，确保循环始终执行至少一次。
21	5	[27]	基于控制语句，涉及重复，涉及终止测试。
10	3	[5]	所有构造函数都是函数，但并非所有函数都是构造函数。此外，函数可以具有几乎无限的用途，而构造函数始终创建您所使用任何类的实例。您可以更改构造函数做某事，但更改它所做工作。使用函数，您不仅可以更改如何，还可以更改什么。
21	3	[15]	两者都需要有某种基本大小写来判断循环何时需要停止。
6	4	[1]	变量通常在程序开始时声明C++，但只要变量在调用之前出现，就可以在程序中声明任何变量。
17	4.5	[6]	它在该位置扩展函数的定义。 调用函数后，您可以尽可能多次地使用它。 编译器只是扩展函数。
1	2	[24]	在程序最终确定之前查找问题和错误
12	5	[1]	程序员想要创建的人很多。
17	5	[30]	该符合符包括内联函数的副本，而不是进行函数调用，但通常只使用非常小的函数。
8	3	[9]	它是特定的类名，仅包括该类定义的信息...实现细节...等。
18	3	[12]	它效率更高，它更改变量不是函数内部联机，而是外部，以便新值可以在其他位置使用。
7	5	[16]	但是，在检查条件之前，执行时间至少经过 1 次，如果条件最初失败，则一段时间将无法进入循环。
3	2.5	[3]	优点是 OOP 允许我们构建对象类。 OOP 的三个原则是：<br><br>属性- 对象结合数据和<br><br>继承 - 类可以从其他类继承属性。<br><br>变形 - 对象可以在执行时确定适当的操作。
2	4	[22]	改进解决方案
11	3.5	[5]	编译期间
10	4	[23]	构造函数不返回任何日期，并且没有返回类型。<br><br>功能可以返回日期，或者不返回数据可以具有返回类型。
11	3.5	[23]	当它的程序编译
19	5	[18]	它查看函数调用中参数的数量、类型和顺序<br>
2	3.5	[9]	精炼、生产、维护
5	3.5	[24]	可以保存数字或字母值的命名对象
3	4.5	[6]	模块化，能够重用程序的某些部分，有时与完全不同的程序目标。此外，通过将代码划分为每个类执行特定作业，以及当程序在一个作业中失败时，您只有一个类要调试，从而更容易调试代码。出于安全目的，它允许您允许某人使用对列表进行排序的程序，而不必赋予他们访问源代码的访问权限。ALso 允许您使用继承和多态性。
13	4.5	[14]	函数原型描述了一个类接口，而不斥责里面的任何，因为函数定义不能这样做。<br>
12	5	[4]	在C++中，可以重载构造函数，因为类可以有多个构造函数，每个构造函数具有不同的参数。
8	5	[18]	数据成员和成员函数
5	4.5	[5]	在编程中，一个包含数据且由程序员唯一命名的结构。它保存分配给它的数据，直到分配新值或程序完成。<br>
4	5	[16]	在主
10	2.5	[6]	构造函数初始化类的对象。 类的函数执行一项任务，如显示一行文本或执行某种数学运算。
7	3.5	[27]	while 循环在循环的开头终止，do/while 在循环的末尾终止。
19	5	[1]	按数字以及参数的类型和顺序。
3	1	[24]	面向对象的编程允许程序员将对象与类一起使用，这些类可以更改和操作，同时不影响整个对象。类都包含影响对象的操作。
7	5	[10]	while 语句在条件可以启动之前测试条件。<br>做...而语句在测试条件之前循环一次。
20	5	[23]	如果在每个递归调用中，问题不会减少，或者它不会减小到基本情况，则可能导致无限递归。
3	4	[9]	可重用的组件、可扩展性、可维护性，可减少大问题，使问题更小、易于管理。
16	5	[11]	全局变量都有文件范围。
21	0	[12]	未回答
15	5	[11]	函数签名包括函数的名称和参数类型，但不包括返回类型。<br><br>
13	4	[6]	函数定义不需要在其括号内传递任何其他信息<br>执行。虽然定义原型需要传递多个参数才能完成其<br>任务。
4	5	[6]	在函数\ t 手 （）] ™
10	4	[19]	构造函数用于创建类的实例，并且与该类具有相同的名称。函数不能与类具有相同的名称并计算数据。
16	4.5	[27]	全球，在程序的任何地方。
20	5	[2]	省略基本大小写或错误地调用递归步骤。
2	2.5	[26]	1- 规格<br>2-设计<br>3-风险分析<br>4-验证<br>5-编码<br>6-测试<br>7-精炼<br>8-生产<br>9-维护
13	4.5	[1]	函数定义包含函数工作的所有代码。函数原型只显示输出、输入和函数名称。
2	1.5	[7]	根据工作完成情况，测试将分散到整个<br>流程中，以防止因缺少<br>foright.<br>
13	4.5	[19]	原型仅声明名称、返回类型和输入类型。<br>定义还定义了范围、变量、过程和返回函数
5	5	[15]	内存中可以存储和检索数据的位置
12	0	[16]	一
14	4.5	[6]	标头文件的作用列出了类在隐藏其函数的内部工作时可以执行的所有函数<br>
1	5	[5]	使用快速、简单的程序来模拟所需最终产品的某些部分，该程序可执行小型特定工作。这是一种帮助查看问题是什么以及如何在最终项目中解决它的方法。
10	3.5	[22]	每当创建该类的新对象时，都会调用构造函数。
18	3.5	[20]	比通过值传递的开销少，尤其是在使用大数时。
20	2.5	[5]	设计不良的阿尔戈里西姆斯。使用递归解决非递归问题。
11	5	[25]	如果类未显式包含构造函数，编译器将创建一个构造函数。
19	5	[29]	基于函数调用中参数的数量、类型和顺序。
1	4	[8]	原型程序模拟所需软件产品部分的行为，以便进行错误检查。
17	2	[24]	在标题中或 int main（） 之前声明内联函数。然后，您可以在主程序中随时快速轻松地调用该函数。
10	5	[26]	构造函数不能返回值，它甚至不无效。它用于在创建对象时初始化对象的数据。<br>，创建函数来执行特定任务，并且它可以返回值。
16	5	[9]	程序的任何部分都可以访问它们。它可以由遵循源文件中的声明或定义的任何函数引用。
14	4.5	[9]	提供有关库内容的信息。它包括类的定义、函数的声明、数据类型和常量。
21	4.5	[23]	两者都是重复的，并且都有结束测试。
2	3	[20]	精炼、生产和维护
9	4	[29]	数据成员在类定义中声明，但在类的成员函数定义的实体之外。局部变量在函数定义的正文中声明
18	4.5	[5]	因为您无法更改原始和通过引用限制传递程序所需的内存。
11	5	[28]	当一个类未显式包含时<br>
21	5	[18]	它们都基于控制语句， 都涉及重复， 都涉及终止案例， 两者都涉及终止案例， 两者都可以无限发生
12	5	[19]	只要签名不同，就可以有无限构造函数。
21	5	[25]	两者都是基于控件语句。两者都涉及重复。两者都涉及终止测试。两者都逐渐接近终止。两者都可以无限发生。
4	5	[27]	加载所需的 include 语句和库后，主方法开始执行。
6	4.5	[15]	任何地方， 但您声明它们取决于您希望它们可访问的地方 （它们的范围）
12	5	[27]	所需的/需要的要多
21	5	[10]	两者都涉及终止测试。 <br>他们使用控制语句和重新声明来解决问题。<br>他们也可以导致一个无限的循环。
19	5	[7]	其功能签名。
9	4.5	[23]	数据成员是函数的属性，可以在函数外部使用。<br>本地变量不能在函数外部使用，并且函数终止后该值将丢失。
18	5	[6]	总的来说，程序具有更好的性能（意味着它更快），因为它不必复制大量数据。
17	5	[13]	内联函数将就地复制，而不是被引用。
14	3.5	[18]	允许编译器在其他地方使用时识别类。
14	3	[16]	允许编译器在其他地方使用时识别类
19	5	[19]	编译器通过签名区分重载函数。
17	5	[28]	它生成函数代码的副本， 以避免函数调用
19	4.5	[13]	重载函数按其参数进行区分。
1	5	[20]	它模拟所需软件产品部分的行为
12	0	[18]	一
10	3.5	[31]	构造函数是用于在创建对象数据时初始化对象的函数。
14	3.5	[27]	将源代码与主函数分离，允许在程序中包含方法/类，而无需直接编码。允许重新可用性。
4	5	[7]	主要功能。
6	5	[9]	它们可以在主要方法之前全局声明 （但也在它之外）...或变量只能受它们在内范围的方法的受制于，但仍将在该方法的开头声明（但在该方法的开头）。
13	4.5	[23]	函数原型位于 .h 文件中，仅包含访问函数名称和参数类型。<br><br>功能定义包含函数执行其活动的代码。
12	5	[13]	根据需要使用，具体取决于在实例化对象时希望直接修改或保留为默认值的变量数。
5	5	[31]	内存中可以存储值的位置。
3	3.5	[20]	现有类可以重复使用，程序维护和验证更容易<br>
6	2	[6]	它们可以在使用之前声明，但在程序的开头声明它们并标记它们是什么食物是一个很好的做法。
20	5	[6]	一个基本情况，这是问题最简单的情况，以便函数将导致它，如果这不会发生，那么它最终将成为一个无限循环。以及知道何时终止的条件。
11	5	[7]	编译器会自动为您创建此函数，除非您专门创建一个。
2	2	[28]	测试可能会影响生命周期的所有部分;它会让你回到<br><br>， 如果它测试不好。
10	4	[4]	构造函数不能返回值，因此不能指定返回类型。通常，构造函数声明为公共。
20	3	[14]	递归是指函数调用自己的情况。这些类型的函数称为递归函数。话虽如此， 无限递归发生时， 函数的设计方式， 以永远调用它自我， 而不停止可能的原因
7	5	[18]	While 循环在其循环的顶部计算其表达式，并决定是否需要执行，Do-while 始终至少执行一次，然后在循环的底部计算其表达式。
3	3.5	[18]	现有课程可以修改，程序维护和验证更容易
12	5	[15]	只要它们都有一个唯一的参数列表， 只要它们都有一个唯一的参数列表
17	3.5	[19]	如果需要，它将生成函数的副本。
2	2.5	[29]	细化阶段的后半部分、施工阶段和过渡阶段。<br>
10	2.5	[28]	构造函数初始化数据，然后用于计算<br><br>函数
3	4.5	[13]	模块化、可重用的代码，允许更快地部署解决方案，并更普遍地查看解决方案。
10	2.5	[1]	构造函数初始化对象。函数是对象的一部分。
3	3.5	[7]	数据抽象和控制...将元素与其他元素<br>元素，防止数据被篡改。<br>
15	5	[2]	函数的名称及其参数的类型
5	5	[16]	内存中可以存储值的位置。
18	4	[26]	它需要更少的内存， 因此它会使程序更快
18	4	[19]	可以直接修改数据，而不是复制数据。利用大量数据缩短执行时间。
1	2	[1]	原型程序的作用是帮助发现实际编程过程中可能出现的关键问题。
16	2.5	[3]	全局变量的范围通过将变量声明置于任何类或函数定义之外来创建。 全局变量在整个程序执行过程中保留其值，并且它们可以由遵循其声明或源文件中定义的任何函数引用。
13	3.5	[27]	原型在编译前状态该类中的所有函数，其中定义实际包含函数的源
7	5	[5]	做...而语句计算在运行其中包含的块后是否循环至少一次。因此，主要的区别是，虽然语句有可能永远不会被使用。做...而另一方面，在评估是否再次运行之前，始终至少运行一次语句。
15	5	[28]	函数名称和参数类型
14	1.5	[13]	#include"hat.h"允许使用帽子容器，所以从帽子里拉名字的行为。 帽子的头文件包括用于存储和检索其内容的功能，主要是 put（）、窥视（）和拉（）。
17	3.5	[22]	函数不与其他函数一样被视为单独的单元
5	3.5	[20]	内存中可以存储值的位置的对象<br>
14	3	[10]	它包含可重用的源代码供其他类使用。
2	4	[5]	实施阶段和维护阶段生效
4	0	[22]	在测试阶段
21	4	[9]	两者将重复（循环），直到满足条件，并退出循环。两者都能够进入无限循环。
14	2.5	[25]	标题文件在程序程序器可以使用的文件中具有可重用的源代码。
21	3	[21]	任何你可以重复性地做， 你可以重复做
7	0	[1]	无答案
20	5	[9]	不正确或缺少基本大小写。必须减小到基本情况。函数每次运行时必须变得更简单（收敛到基本大小写）。
17	5	[11]	对于内联函数，编译器将创建函数代码的副本，因此它不必进行函数调用并添加到函数调用堆栈。
17	0	[7]	未回答
7	5	[9]	while 语句将测试 while 循环 FIRST 的条件 - 循环可能永远不会运行。A 做...while 循环将始终运行一次，然后 while 测试将确定它是否会再次运行。
11	5	[27]	当不存在用户定义的构造函数时
11	5	[21]	当提供非
9	4.5	[10]	每个成员函数都可以访问和修改数据成员。<br>一个局部变量只能在从声明行到下一个关闭之前从内存丢失。
8	5	[11]	它以类开头，后跟类名，然后通常包含任何类的定义中，包括构造函数、数据成员和描述类的成员函数。
16	4.5	[16]	通过程序
13	4	[30]	函数原型简单地声明函数参数，函数定义包括任何必要的变量和函数的实际代码
20	5	[11]	如果递归函数永远不会达到或成功定义基本大小写，它将永远递归。<br><br>发生这种情况的方式有很多种，例如函数不会向基例中推进，或者函数编码错误，甚至不包含基例。
