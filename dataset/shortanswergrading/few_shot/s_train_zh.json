[
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件是源文件之间的交叉通信方法，可帮助限制每个程序的大小。没有头文件，程序将是一个大的代码块，因此相当难以调试和遍历。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型告诉编译器函数名称、返回类型以及参数的数量和类型，而不显示函数定义中包含的实现。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在主函数中...？",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "指向内存中位置的指针。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "变量可以在类和方法中声明。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "while 语句将仅在满足语句时处理， 而 do...而将始终处理一次，则仅在满足语句时继续。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "允许编译器在其他地方使用时识别类<br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "while 循环是预检查（它会在 while 块内执行代码之前检查条件语句）<br><br>当循环是后检查时检查（它检查条件后块执行，它至少运行一次，无论条件语句是什么）",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "类定义通常包含函数及其数据成员",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件通常包含类和/或函数原型。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "精炼和编码",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数不能返回值，因此它们不能像函数那样指定返回类型。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "函数可以直接修改通过引用传递的参数。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "迭代和递归都基于控制语句，并涉及重复。它们也可以无限期地发生。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "没有基本情况。<br>递归步骤不会减少每次递归调用期间的问题。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "它直接提供访问和修改调用方的参数数据。它消除了复制大量数据的价值开销",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "重载函数必须具有相同的返回类型，但输入参数不同",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "在整个程序执行",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据<br><br>本地变量在函数定义中声明™的正文<br>它们不能在该功能体之外使用。<br>函数终止时，其局部变量的值将丢失。<br><br><br>",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "-验证<br> - 调试",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "公共部分和私有部分，必须有一个分号来设置结束",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "类中的构造函数数没有限制，因为与函数一样，构造函数可以重载。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "-在内存中保存位置的标识符。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "迭代和递归都使用重复，并连续执行几个简单的操作和算法，直到它们达到一定的限制。 因此，两者都涉及终止测试以查找该限制，并且两者都缓慢地接近该终止限制。 两者都基于控制语句。 <br><br>如果编码错误，两者都可以永远继续，直到编译器或计算机锁定、关闭或停止操作。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量可以 b 由变量类中的任何类 wit 访问对象",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器通过重载函数的签名来区分重载函数。它将每个函数标识符及其参数的数量和类型编码，以生成类型安全链接，从而确保调用正确的重载函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数是在创建对象时调用的特殊语句块，在静态声明或堆栈上构造对象时调用该语句块。但是，函数是较大程序中代码的一部分，它执行特定任务，独立于代码的其余部分。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "该类可访问的构造函数、函数和变量，可能还可访问其他类，具体取决于它们如何完成。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "细化、 施工、过渡",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当类未显式包含构造函数时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "封装 - 对象在不知道操作工作原理的情况下使用操作。<br>继承 - 通过重用较早的类来减少冗余。<br>变形 - 对象选择在这种情况下使用的正确操作。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "属于类的函数和数据成员",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "它们用于解决相同类型的问题。他们一遍又一次地执行一项任务，直到到达循环条件语句（在递归中称为基本大小写）。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都基于控制语句， 两者都涉及重复， 两者都涉及终止测试， 两者都逐渐接近终止， 两者都可以无限发生",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量具有文件范围",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型描述类的公共接口，而不<br><br>类的成员函数实现，函数定义显示<br><br>实现",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数不需要类型，它用于初始化变量。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数是启动类的新实例的方法。（例如：员工员工 1（参数）启动类型为\"员工\"的对象的新实例）。函数只是一个模块，它位于程序中，可以完成其所需的单个任务。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员在类内声明，但在任何成员函数之外。与局部变量不同，类的每个对象都保留存储在内存中的数据成员自己的副本。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "函数调用将被内联函数中定义的代码替换",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "while 循环首先检查条件是否为 true，如果为 true，它将执行语句。<br>一下， 而循环在检查条件之前执行语句。如果条件为真， 它会再次执行语句。而循环将执行语句至少一次。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "与常规函数不同，构造函数仅在创建对象时™对象的数据。构造函数还必须与 类同名，并且不能返回任何值。<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数的名称及其参数的类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "整个程序或文件。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在使用之前，在同一范围内的任何地方",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "它包括函数的名称及其参数的类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "将函数扩展到程序中",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "如前所述，递归可用于处理迭代操作。递归用于计算答案可以在与自身相关的函数中描述。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "精炼步骤、生产步骤和维护阶段。<br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "它将该函数调用的所有实例替换为内联代码本身，从而生成更长但更快的程序。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "数据和功能",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "原型仅显示返回类型和必要参数。该定义包括这些参数的名称，并定义对象实际能够执行哪些操作。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "编译器忽略内联限定符",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "程序编译时，将复制函数，避免函数调用。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "封装对象组合数据和操作<br>继承 -类可以从其他类继承属性<br>多态性 - 对象可以在执行时确定适当的操作",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "使调用函数能够直接访问和修改调用方的参数数据。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "在运行一个复杂函数的一开始，在C++，如果用户没有提供其他构造函数，它为类生成自己的默认构造函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "通过引用传递可以消除复制大量数据的按值传递开销。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "重载函数通过其签名、名称修饰或名称修饰进行区分，并且类型安全链接可确保调用适当的重载函数，并且参数的类型符合参数的 tpes。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "做和做的主要区别...当语句在做...而语句是 do 块中的语句始终至少执行一次。<br> while 语句仅在其条件为 true 时才执行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "默认情况下只有一个， 但它们可以重载以创建尽可能多的构造函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "数据成员和成员函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都基于控件语句。<br>两者都涉及重复。<br>两者都涉及终止测试。<br>两者逐渐接近终止。<br>两者都可以无限发生。<br><br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "细化、构建和过渡都受测试影响",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "内存中可以存储值的位置",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "不必复制东西。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "它模拟所需软件产品部分的行为",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "做，而循环总是执行一次。while 循环的条件语句必须为 true 才能运行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当没有通过参数时。",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "局部变量在方法内声明，而全局变量在正文中声明。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "可由源文件中遵循其声明或定义的任何函数引用",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "原型仅告诉用户哪些数据类型进入函数以及返回什么类型。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数签名由函数原型组成。 这将告诉您有关函数、其名称、参数、函数位于什么范围和其他杂项信息的一般信息。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "使用不同的模块可以更轻松地进行调试",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数的名称及其参数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "functgion 原型是函数的声明，而函数定义指定函数的作用",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "成员乐趣和数据成员",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数名称和参数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "对于一个封装来说，对象内部的变量值是私有的，除非编写方法将信息传递到对象之外。以及继承，其中每个子类继承其超级类的所有变量和方法。 书中的示例包括 obj 时钟以及 obj 闹钟如何仍然使用第一类的时钟。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数用于创建可用于程序主函数的对象。 这可能与它一起执行代码，也可能不执行代码。<br><br>一个函数是一组代码，在调用时执行，但不会创建新对象。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "表示值的符号，该值可能更改，也可能不更改，具体取决于程序。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "只能在其声明范围内访问局部变量。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "方法内部。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "迭代和递归有许多相似之处：两者都基于控制语句、涉及重复、涉及终止测试、逐渐接近终止并可能发生无限。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "较低的开销，并直接修改变量。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "除设置程序要求外，所有阶段都受到影响。 如果测试失败，它可以更改程序的整个设计、实现等以及最终结果。",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "它通过在程序中插入函数的代码来生成函数代码的副本。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在主函数内",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "如果函数足够小，它将扩展它，但它将运行得更快，因为它将避免对函数进行这么多调用。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "它包括程序的名称，它可以采取的参数的类型。它还应包括函数作用的简要说明。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在代码的任何地方，可以在顶部，或在代码的中间，或任何地方。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "不能在声明本地变量的函数之外访问局部变量。数据成员通常是私有的。声明私有的函数的变量只能对声明它们的类的成员函数进行访问。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "字段变量是声明为类成员的变量。局部变量是声明方法的局部变量。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "其中一个主要优点是您可以隐藏内部细节，这是一种通过封装已知的技术。对象合并数据和操作，但您无法看到它的工作原理。<br>另一个优点是，您可以重用在程序中早期定义的类，这种方法称为继承。<br>另一个优点是对象可以在执行时确定适当的操作，一种称为多态性的技术。<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它们由编译器根据用于重载函数之一的条件/输入进行区分。",
        "label": 0.6,
        "category": "3"
    }
]