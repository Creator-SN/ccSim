[
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "如果变量声明为全局变量，则任何函数或类都可以使用该变量。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "这取决于它是一个™，那么它们必须声明出要在每个作用域中使用的源代码，但是局部变量是本地函数中声明的变量等，这显然不需要在变量之外声明 ™，看看它如何用于函数或阻止其被调用。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "按其签名（返回类型、参数列表）",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "变量在主函数中声明，在尝试<br><br>任何操作之前。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "输入参数和返回类型",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数在实例化对象时设置变量的默认值，而函数允许与该对象交互。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都涉及受控的重复结构，并且它们都有终止测试。 此外，他们两个可以永远循环。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "这取决于类中的数据成员数",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当不需要构造函数时，将声明一个无参数的默认构造函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "它包括函数的名称及其参数的类型。它不指定函数返回类型。同一作用域中的函数必须具有取消qiue 签名。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当类未明确包含 consructor 时，编译器将提供一个。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型仅命名函数、其返回类型和参数列表，而定义定义上述以及函数实际操作的功能。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "它包括程序的名称，它可以采取的参数的类型。它还应包括函数作用的简要说明。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "基于控制语句; 涉及重复;涉及终端测试;两者都可能发生在<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "类变量，类的函数定义",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "类是数据结构的扩展概念，它同时保存数据和正在执行的函数",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "函数绝不允许到达\"基本案例\"",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当您不指定任何构造函数时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "它们使重用和调整以前编写的代码更加容易，并且它们将复杂程序分离成更小、更易于理解的类。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "唯一函数签名",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "它包括有关函数的特定信息，如输入和输出变量类型以及每种变量类型中有多少个。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "编译器忽略内联限定符",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "它没有基本案例， 或基本案例永远不会满足",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "整个程序",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "声明类中使用的函数",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "它是值/数字的元或名称。示例：\"a_used_number\"可以代表任何给定的数字，程序员可以使用变量名称引用该数字。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "变量是计算机内存中的位置，可以在其中存储值，以后可以检索该值。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "尽可能多的， 你需要",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "现有的类可以重复使用<br>和验证更容易",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "面向对象编程的主要优点是现有类可以重用，并且程序维护和验证更容易。<br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数没有返回类型。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "一",
        "label": 0.0,
        "category": "0"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在顶部",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在主函数内",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "既基于控制语句， 涉及重复， 也涉及循环内的终止测试",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "关键字类后跟类名，内部声明类的公有和私有声明",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "直接提供对调用方数据的访问权限，还允许修改数据。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "你不做另一个副本和浪费内存",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型只是现有函数的声明，不能用作实际函数。必须使用 内部定义创建函数，以告诉编译器函数的作用。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "局部变量仅在定义它的函数中可用，而数据成员可用于其类中的任何方法",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "全局用于整个程序，并本地用于单个函数（包括 FOR 语句）",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "没有基本<br>， 如果程序马尔没有将基本大小写定义为最简单的情况， 并且永远不会到达",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都基于控制语句，两者都涉及重托，都涉及终止测试，两者都逐渐接近终止，两者都可能发生在内特。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "每当你不指定你自己的",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "变量可以是程序中的整数或字符串。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当我们不在类文件中定义一个构造函数时，编译器将创建一个默认构造函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数名称和输入参数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "-验证<br> - 调试",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "通过引用传递可以消除复制大量数据的按值传递开销。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "一个构造函数和几个数据成员，以及至少一个公共数据成员或方法",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数签名包括方法名称和输入类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "细化、构建和过渡都受测试影响",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "如果函数的参数大小较大，则计算时间和内存空间不会浪费复制参数并传递到函数。 通过引用传递也给出了称为函数直接读取编辑参数的权限。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "用户决定使用的。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "如果函数足够小，它将扩展它，但它将运行得更快，因为它将避免对函数进行这么多调用。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "迭代和递归都使用重复，并连续执行几个简单的操作和算法，直到它们达到一定的限制。 因此，两者都涉及终止测试以查找该限制，并且两者都缓慢地接近该终止限制。 两者都基于控制语句。 <br><br>如果编码错误，两者都可以永远继续，直到编译器或计算机锁定、关闭或停止操作。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "没有容易到达的基本案例，也没有基本案例",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "局部变量在方法或函数中声明，它们将在方法的开头使用。全局变量声明在任何函数或方法之外，通常在定义函数之前。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "仅将内存地址发送到函数，因此无需复制发送的对象。它使函数运行得更快，并节省内存。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "一",
        "label": 0.0,
        "category": "0"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "它支持了复制大量数据所需的需求",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数将类对象创建到内存中，其中函数对该对象执行操作",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "局部变量仅在其声明范围内使用",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "类中的构造函数数没有限制，因为与函数一样，构造函数可以重载。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "由于类是用户定义的，因此声明的正文可以包含成员，可以是数据或函数声明，也可以是访问指定器。 说明符的示例将是公共的、私有的和受保护的。 有关键字类，类正文用括号 （+） 括起来。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型是程序员声明他/她使用的是 main （这就像声明一个变量，程序员知道他/她将来将使用，但还没有说他们将在哪里使用它，或如何使用它。这是回答谁的问题，它给函数一个名称和字符。函数原型，按常用做法放置在程序的开头后，#includes主（） 之前。<br>函数定义是函数的内脏。这是程序员决定函数要做什么并告诉它如何执行它的地方。它包含任何信息，并执行操作。它的工作原理有点像大脑，大脑接受输入，并基于输入执行某种方式产生输出。函数定义位于主 （ ） 和任何其他函数之外。函数是它自己的实体，应该这样考虑。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "省略基本大小写，或不正确地写入递归步骤",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "按其类型（int、字符等）",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型描述类的公共接口",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "原型创建一个框架来调用函数定义。虽然函数定义是函数实际编程并创建为最终产品的地方。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数定义就是这个定义。原型是编译器用来检查对函数的调用是否正确的。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "为了良好的编程实践，应在 main（） 之前声明它们，但至少应在使用之前声明它们。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在主（） 函数中。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当特定类还没有一个时",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当不设置参数时，即使用默认构造函数时。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "该类可访问的构造函数、函数和变量，可能还可访问其他类，具体取决于它们如何完成。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "变量在本地块内或全局块外部定义的地方声明。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "类定义放在这里",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "当编译器内联扩展函数调用时，函数的代码将插入到调用方的代码流中（在概念上类似于使用宏#define情况）。这可以从其他一些情况来提高性能，因为优化器可以在程序上将调用的代码集成为\"将被调用的代码优化到调用方中。<br><br>",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "不能在声明本地变量的函数之外访问局部变量。数据成员通常是私有的。声明私有的函数的变量只能对声明它们的类的成员函数进行访问。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "原型程序提供了一个基本的基础，从中可以进一步增强和改进问题的解决方案。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "它把它们当作相同的功能",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "理论上是无限的，只要它们是由程序员定义的。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "变量是内存中可以存储值的位置。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "较低的开销，并直接修改变量。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在根",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都基于控制语句， 两者都涉及重复， 两者都涉及终止测试， 两者都逐渐接近终止， 两者都可以无限发生",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "原型程序用于解决问题，以收集问题数据。",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型仅指定参数。 函数定义包括参数和代码体。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "do...while 语句通常在循环的末尾，因此它至少运行一次。至于 while 语句，如果条件一开始为 false，则循环将永远不会运行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "其参数的数量和类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数初始化数据成员，但函数实际执行任务。构造函数也不能返回值。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数的名称及其参数的类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "只要它们具有不同的参数，就尽可能多。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "整个程序或文件。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "迭代和递归都基于控制语句，并涉及重复。它们也可以无限期地发生。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数不能返回值，甚至不能 void，但函数获取返回值。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "成员函数中的局部变量必须为静态变量。数据成员可以自由更改其值。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "这取决于对象的数量。每个对象都应该有一个构造函数。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "现有的类可以重复使用，程序维护和验证<br><br>更可怕。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "1",
        "label": 0.0,
        "category": "0"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "重载函数只是 invovles 在类中使用相同的名称。重载基于对象存在的上下文为对象提供不同含义的概念。重载是多态性之一，这也是编程中的一个功能。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "编译器可以忽略内联限定符，通常对除了最小函数的所有函数都忽略。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数在其实例化执行时初始化值。它提供默认值。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型是一个声明。 函数定义（带多个参数）通常需要多条信息。执行他们的任务。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "本地变量仅在成员函数内访问，而<br><br>整个类中可以访问数据成员",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "刺激所需软件产品部分行为的程序。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "使调用函数能够直接访问和修改调用方的参数数据。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "变量是计算机内存中可以存储值以供程序使用的位置。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件声明类、其数据和通过该类可用的函数。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数及其参数的数据类型的标识，具有名称和数据类型变量",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "成员函数和数据成员。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "它们通常在开始声明，然后才能在程序中使用。它们始终包含名称和数据类型。<br>",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数原型包含函数名称及其参数类型的部分",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "一个做...while 循环将始终运行一次，而 while 循环<br>运行循环之前执行测试。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据<br><br>本地变量在函数定义中声明™的正文<br>它们不能在该功能体之外使用。<br>函数终止时，其局部变量的值将丢失。<br><br><br>",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "在任何未显式包含构造函数的类中。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量的范围在文件级别。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "它是计算机内存中可存储供程序使用的位置。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "其中一个主要优点是您可以隐藏内部细节，这是一种通过封装已知的技术。对象合并数据和操作，但您无法看到它的工作原理。<br>另一个优点是，您可以重用在程序中早期定义的类，这种方法称为继承。<br>另一个优点是对象可以在执行时确定适当的操作，一种称为多态性的技术。<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数是启动类的新实例的方法。（例如：员工员工 1（参数）启动类型为\"员工\"的对象的新实例）。函数只是一个模块，它位于程序中，可以完成其所需的单个任务。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量具有文件范围。 变量是通过文件知道的所有函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "包括函数的名称及其参数的类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "程序使用的存储值",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它们必须具有相同的返回类型， 但输入参数不同",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数是在创建对象时调用的特殊语句块，在静态声明或堆栈上构造对象时调用该语句块。但是，函数是较大程序中代码的一部分，它执行特定任务，独立于代码的其余部分。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "忽略内联限定符，通常对除了最小函数的所有函数都这样做。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "它生成函数的编码副本，从而消除了调用函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "While 循环用于执行代码块，只要某些条件为 true。 A 做...而循环用于执行代码块，只要满足某些条件。 时与做的区别...而是当循环测试其条件之前执行其内容和 do...而循环在执行其内容后至少测试一次其条件。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "头文件包含可用于多个文件的代码",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "模拟问题部分的解决",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员是全局可访问的，而局部变量只能在成员函数内访问。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "它将该函数调用的所有实例替换为内联代码本身，从而生成更长但更快的程序。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "对象和数据。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "做...虽然运行嵌入代码至少一次，do 命令不一定",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "当编译器内联扩展函数调用时，函数的代码将插入到调用方的代码流中（在概念上类似于使用宏#define情况）。这可以从其他一些情况来提高性能，因为优化器可以在程序上将调用的代码集成为\"将被调用的代码优化到调用方中。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "当省略基大小写或重复步骤写入不正确，以便永远不会在基大小写上收敛时，可能会发生无限递归。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数不能返回值，因此它们不能像函数那样指定返回类型。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员是存储特定C++的类或结构的一部分...成员函数中的局部变量仅在该函数内可用，可用于派生所需的结果。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件由\"可重用\"源代码组成，如文件中的类，按约定具有 .h 文件名扩展名。这与包含\"源代码\"的 .cpp 文件不同。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "主要方法",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "隐藏类的定义和详细信息。 也为了帮助主文件的可C++。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "数据和方法",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "各个组件和步骤（如分析、设计和实现代码）以及整个系统都经过测试，以执行分析阶段确定的要求。即主输出",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "按其参数的数量、类型和顺序",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "编码",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数的名称及其参数的类型",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "模拟所需软件产品部分行为的程序",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在主函数中...？",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当没有通过参数时。",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当构造函数的类中未指定构造函数时，但该类在程序中实例化。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "他们开始执行在 funcion 主 （） 。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "头文件有权访问标准库C++类等类工作。",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数不能返回值",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型是函数的声明，它告诉编译器函数的名称、其返回类型及其参数的类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "省略基大小写，或错误地写入递归步骤，以便它未到达基大小写可能会导致无限递归。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "而不是每次调用函数时调用函数，编译器将用函数体的副本替换函数调用",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "不",
        "label": 0.0,
        "category": "0"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "告诉编译器将函数的代码副本用于位，以避免函数调用。 它通常忽略它，除了最小的函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "任何你想要的号码",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "数据成员和成员函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "是一个方法或标识符，我会说，我们使用绑定数据对象到内存位置;然后存储在一个位置，可以在调用变量名称时访问该位置，并在以后调用变量名称时对其进行操作。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "主要",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在全局变量的情况下，在函数范围内和函数范围之外",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "由其函数签名",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当您不提供自己的构造函数时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "成员函数中的变量只能在成员内部访问，并且可以通过程序访问数据成员。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "封装对象组合数据和操作<br>继承 -类可以从其他类继承属性<br>多态性 - 对象可以在执行时确定适当的操作",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "全局变量在主函数中声明<br>在任何其他函数中声明的本地变量",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "没有基本情况。<br>递归步骤不会减少每次递归调用期间的问题。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "原型不包含函数具有在程序中执行的所有代码的任何实际代码。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "1- 现有类可重复使用<br>2- 程序维护和验证更容易<br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "任何用户都可以在任何地方访问C++文件。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "它们用于解决相同类型的问题。他们一遍又一次地执行一项任务，直到到达循环条件语句（在递归中称为基本大小写）。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数的名称及其参数的类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当类未显式包含构造函数时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数的返回类型和参数列表",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "inline 关键字建议编译器将函数的代码复制到位，以避免函数调用;但是，编译器可以而且通常忽略除了最小函数外的所有函数的内联限定符。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "省略基大小写，或错误地写入递归步骤，以便它不会在基大小写上收敛",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "原型程序是软件问题索尔文规范阶段的一部分。 它被用来说明如何在程序中解决关键问题或问题，有时作为扩展的基础程序。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "原型编程是一种编程方法，使一个人能够采取有组织的方法来开发有效的程序，在解决问题时以最小的错误和战略模式。即，书举了一个顾客从银行取款的例子，这种方法在OOA/Design lvl期间采用伪代码级别，然后开始创建解决方案。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "公共和私有区域，包括类中使用的函数和变量",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "通过整个脚本存在的变量。它们的值可以随时在代码和 fucnction 中更改。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "c++ 程序开始在主方法中执行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "名称、参数、范围和其他一般功能信息",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数初始化值，函数通常执行某种操作。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器通过重载函数的签名来区分重载函数。它将每个函数标识符及其参数的数量和类型编码，以生成类型安全链接，从而确保调用正确的重载函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都基于控件语句。<br>两者都涉及重复。<br>两者都涉及终止测试。<br>两者逐渐接近终止。<br>两者都可以无限发生。<br><br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "默认情况下只有一个， 但它们可以重载以创建尽可能多的构造函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数是初始化类实例的函数，函数执行为它编写的任何任务",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "引用的原始变量可以直接由被调用的函数修改。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员在类内声明，但在任何成员函数之外。与局部变量不同，类的每个对象都保留存储在内存中的数据成员自己的副本。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "它们可用于整个程序",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "[do] 语句首先计算条件，然后执行语句 0 或更多次中的代码行。<br>",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "只要包含适当的 .h 文件，则全局变量可用于任何函数",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "如果未定义基大小写，或者调用没有变化，可能会发生无限递归。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "在任何未显式包含构造函数的类中。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在主函数<br><br>主 （）",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型告诉编译器函数名称、返回类型以及参数的数量和类型，而不显示函数定义中包含的实现。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数的名称及其参数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器从函数调用中参数的数量、类型和顺序中选择正确的函数来执行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量具有文件范围",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "现有类可以重复使用<br>程序维护和验证很容易",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都基于控件语句;两者都逐渐接近终止终止结束与终止测试;两者都涉及重复，如果未满足终止要求，则两者都可以无限重复。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "它测试程序的主要功能，同时留下更精细的细节。<br>",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "C++程序开始在主函数执行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "在\"主\"功能中",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "使用不同的模块可以更轻松地进行调试",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "循环体始终至少执行一次<br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "可由具有 和 对象的任何类在其中具有 和 对象的",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "内存中可以存储值的位置",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "公共部分和私有部分，必须有一个分号来设置结束",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在主函数中，通常在代码的顶部。<br><br>几乎可以在任何地方声明它们，但必须在代码使用或对它们采取行动之前声明它们。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数名称和参数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "告诉编译器哪些数据成员和成员函数属于类的信息。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数不需要类型，它用于初始化变量。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数签名包括函数的名称及其参数的类型",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "-更易于调试<br>可重复性",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "局部变量在方法内声明，而全局变量在正文中声明。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "重载函数必须具有相同的返回类型，但输入参数不同",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "源代码文件中任何跟随其减速的函数都允许访问变量。 此外，全局范围变量在整个程序执行过程中重新训练其值。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它们具有相同的名称，只是不同的参数。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "声明变量的数据类型后。",
        "label": 0.2,
        "category": "1"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "重新提升功能",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "程序编译时，将复制函数，避免函数调用。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "A 做...而语句的正文始终执行至少一次。 其中 while while 语句将不执行，除非 时的条件为 true。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "做，而循环总是执行一次。while 循环的条件语句必须为 true 才能运行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "它模拟所需软件产品部分的行为。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "一段时间和一段时间的主要区别...而循环是做...while 循环始终循环至少循环一次，但 while 循环并不总是这样做。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "在运行一个复杂函数的一开始，在C++，如果用户没有提供其他构造函数，它为类生成自己的默认构造函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "它用于让用户对已完成的程序有第一个想法，并允许客户端评估程序。这可以产生很多反馈，包括软件规范和项目估计整个项目。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "布置基础知识，并给出实际问题解决的起点。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "头文件向用户显示哪些类型进入和从函数中出来，但不允许用户操作函数的实际代码。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它检查每个函数上参数的名称、类型和顺序。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "完善解决方案、生产和维护都受测试阶段的影响。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "它扩展了一个小功能...使代码更长，但也使代码运行得更快。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "do 的循环...而语句始终执行一次。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "变量是计算机内存中可存储值以供程序使用的位置。每个变量都有一个名称、一个值、一个类型和一个大小。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "它是内存中可以存储值的位置<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件通常包含类和/或函数原型。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "仅模拟所需软件产品的一部分行为。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "它包括一个函数名称和参数列表。不包括返回类型。函数签名必须不同。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "如前所述，递归可用于处理迭代操作。递归用于计算答案可以在与自身相关的函数中描述。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "属于该类的成员函数和数据成员。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当类未显式包含构造函数时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "处理不当的情况，因此并非所有可能的值都能够处理。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件是源文件之间的交叉通信方法，可帮助限制每个程序的大小。没有头文件，程序将是一个大的代码块，因此相当难以调试和遍历。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "任何你能做的， 你可以做递归",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "不使用 unessesary 内存空间在函数之间复制变量",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "现有类可以重复使用，程序维护和验证更容易。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "无论条件如何，do while 循环块中的语句将始终至少执行一次。而如果条件未得到满足，则可能永远不会执行 while 循环。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "返回类型和输入参数",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型描述类的公共接口，而不<br><br>类的成员函数实现，函数定义显示<br><br>实现",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "表示值的符号，该值可能更改，也可能不更改，具体取决于程序。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "该类的属性。也它是否是子类。也不管是公私还是受保护。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当类未显式包含构造函数时",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "它提供了有限的概念验证，在实际编程整个应用程序之前与客户端进行验证。<br>",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "C++程序开始在主执行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "编码和调试程序通常更容易，因为编译器将指定工作不正确的对象，或者分配给对象的函数将更易于识别。 代码本身看起来也更加有条理，更易于阅读，有助于避免冗余编码。 编程后维护也更容易。<br><br>，模块可以在其他程序中多次重复使用，而不会太麻烦。  抽象是将一个大问题分解为更小、更简单的问题并解决这些问题的艺术。 许多较小的问题在独特的复杂问题之间共享，创建模块来解决这些问题可以节省时间，当您再次遇到它们。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "函数代码的多个副本入到程序中，使其变大。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "函数调用将被内联函数中定义的代码替换",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在使用它们之前。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "可以通过重载为任何给定类创建大量构造函数。 当创建两个具有不同类型或数量的参数的构造函数时，它们被重载，C++ 可以根据传递/返回的变量类型识别要使用的构造函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "<br>创建基本大小写，或在永远不会满足基本大小写的情况下。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员是特定类的数据组件。 成员函数是类的功能组件。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "您可以将整个程序分解为原型程序，以模拟最终程序的一部分",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "变量可以保持私有。代码易于修改和重用，也易于实现。更别提作为观察者更容易阅读和跟随了。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员是在类定义内声明的变量，但在类成员函数的实体之外。局部变量只能在函数声明中使用。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "将引用（而不是大型对象）传递给函数通常效率更高。这允许编译器传递对象的地址，同时维护用于访问对象的语法。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "变量是存储数据的对象。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "细化、 施工、过渡",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "可以在类外部访问数据成员，而本地变量不能。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "函数可以更改直接通过引用传递的变量中存储的数据。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "原型声明将在程序中使用的和定义",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在代码的任何地方，可以在顶部，或在代码的中间，或任何地方。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "一些优点是现有的类可以重用，程序维护和验证更容易完成。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "您可以修改直接引用的变量。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "几个",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在程序的一开始。在主（）开始前。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "while 循环将检查语句，以确保它在执行之前为 true。在检查语句以查看是否应该再次运行之前，将执行 do while 循环。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数初始化所有内容，以便不留空或使用随机 variouble，并且函数使用数据修改这些变量。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "将限定符内联放在函数的返回类型之前，在函数定义\"建议\"编译器生成函数代码的副本，以避免函数调用。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "变量在实际使用之前声明。它们可以在 main（） 之前声明为全局使用",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "未回答",
        "label": 0.0,
        "category": "0"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "签名可以包括结果类型和引发的错误。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "文件范围",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "方法内部。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "它们是重复相同任务的方法。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "尽可能多的，你想，具有不同的参数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数原型的部分具有函数名称和参数，但没有返回类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "信息可以隐藏。调试更容易。编程更容易，更容易管理。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "主要方法。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "简化对正在讨论的问题的理解，并简化对程序本身的理解",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "删除逻辑错误、测试有效数据、随机数据和实际数据。",
        "label": 0.2,
        "category": "1"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量可以 b 由变量类中的任何类 wit 访问对象",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "-在内存中保存位置的标识符。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "无基例，如不包括再次调用函数的单个返回。 静态值结束。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "功能主",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "在运行前先测试 true 时， 请...而先运行一次，然后检查。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "不会更改传递的变量的原始值。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "成员乐趣和数据成员",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "以显示程序的某一部分工作，因为它应该",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "-在主函数中的任何地方。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "它通过在程序中插入函数的代码来生成函数代码的副本。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "它模拟所需软件产品部分的行为",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "许多问题可以通过迭代和递归来解决，如果省略终止测试，则其中一个问题可能会进入无限执行状态。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "它们可以由源文件中声明或定义后的任何函数引用。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "函数可以直接修改通过引用传递的参数。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "将可重用的内容或模块与可用于不同程序的实际源代码文件分开。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当程序员没有明确包括构造函数时",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "它们在放置在函数外部时具有文件范围。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "它包括函数的名称及其参数的类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "一C++程序将开始在 main（） 函数执行。<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "数据和功能",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件分隔定义类的文件，并允许编译器在其他地方使用时识别类。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "允许编译器在其他地方使用时识别类<br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它们因函数调用中的参数数、类型和顺序而有所不同。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "[结构] 编译器如何与库和用户编写的组件进行接口。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量具有程序范围（可在程序中的任意位置访问）",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量具有文件范围。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "做和做的主要区别...当语句在做...而语句是 do 块中的语句始终至少执行一次。<br> while 语句仅在其条件为 true 时才执行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型按特定顺序排列函数预期接收的名称、返回类型以及参数的数量和类型。 函数原型的详细信息在函数定义中。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "缺少定义基案例，或错误地写入递归步骤，以便它不会在基案例上收敛",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "数据成员和成员功能",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "编译器根据函数调用中参数的数量、类型和顺序选择要执行的正确函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "类名， 两个卷曲的婚前， 公共和私人",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "它们从主（） 函数开始。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在函数声明中，对于语句和 while 语句。<br>在 If、For、同时在命名空间、标题等的正文中执行语句（几乎任何地方）。<br>程序中的任何地方， 只要它是在它自己的行。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数是用于在创建对象数据时初始化对象的函数。在创建对象时，将隐式调用它，并且必须使用与类相同的名称进行定义。构造函数也不能返回函数可以返回的值。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当类未显式包含构造函数时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "17",
        "question": "编译器如何处理内联函数？",
        "text1": "它在进行函数调用的每个位置复制函数代码。",
        "text2": "将函数扩展到程序中",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "在RUP中，软件生命周期中受测试阶段影响的阶段是：<br><br>解释阶段-精炼的正向视觉、核心系统的迭代、系统需求的开发、更准确的时间和成本估算<br><br>构建阶段-剩余系统的迭代开发。<br><br>过渡阶段测试和系统的部署。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "将不同值存储到程序中的方法，如数字、单词、字母等。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "它们由编译器根据用于重载函数之一的条件/输入进行区分。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "由于性能原因，通过引用传递是很好的，因为它可以消除复制大量数据的价值开销。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "-在主函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "重载函数通过其签名、名称修饰或名称修饰进行区分，并且类型安全链接可确保调用适当的重载函数，并且参数的类型符合参数的 tpes。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "原型仅告诉用户哪些数据类型进入函数以及返回什么类型。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "您可以根据需要重载构造函数",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "封装 - 对象在不知道操作工作原理的情况下使用操作。<br>继承 - 通过重用较早的类来减少冗余。<br>变形 - 对象选择在这种情况下使用的正确操作。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "精炼、生产、维护。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "如果测试阶段发现设计中的问题，可以进行优化，并可能进行设计。如果程序当前形式无法工作，这将导致生产时间晚于最初估计，生产可能会受到影响。也会影响编码，因为测试后您可能需要重写代码，程序才能删除错误。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员只要运行，就永久存在于该程序的内存中。<br><br>成员函数内的局部变量是临时变量，仅用于在函数中操作，只要函数运行，就存在。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员可供类中的所有函数访问，其中局部变量仅对成员函数可用，并且函数关闭时值丢失",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "变量可以在类和方法中声明。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "精炼步骤、生产步骤和维护阶段。<br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "全局变量是在整个程序执行过程中保留其值的标识符。它有文件范围。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标头文件允许将声明和实现分离为单独的文件。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型描述类的公共接口，而不显示类的成员函数实现",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "C++在编译期间创建默认构造函数（如果未提供）。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "可以假定一组值中的任何一个的值/单词",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都基于控制语句，涉及重复，并涉及终止测试。两者都逐渐接近终止， 两者都可能发生无限",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "当引用函数或子例程时，实际参数与虚拟参数关联。在过程引用中，实际参数列表标识列表中提供的实际参数与子程序虚拟参数之间的对应关系",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "百度计",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "重复，终止测试，最终终止，发生下",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "没有基例，或未正确写入的递归步骤不收敛在基例上将导致无限递归。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "创建类时调用构造函数，可随时调用函数。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "无需复制整个数据点即可传递大型数据项，从而减少执行时间和所需的内存空间不足<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "不必复制东西。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在使用之前，在同一范围内的任何地方",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数签名包括函数的返回类型、参数和分号。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "提供直接访问和修改调用方参数数据的函数功能",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "尽可能多的你想要的",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "主要功能",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "变量通常在代码模块的开头C++声明。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "编码和精炼",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "全局变量在代码正文中声明。局部变量在要使用的函数中声明（除非传递函数是变量）。变量在使用前应始终声明。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "对于一个封装来说，对象内部的变量值是私有的，除非编写方法将信息传递到对象之外。以及继承，其中每个子类继承其超级类的所有变量和方法。 书中的示例包括 obj 时钟以及 obj 闹钟如何仍然使用第一类的时钟。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "在函数原型中，包括返回类型、函数的名称及其参数（如果需要）。<br><br>函数定义中编写函数将执行哪些项代码。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "国际主（）",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "模拟所需软件产品部分行为的程序。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "用于保存程序中使用的信息的占位符...<br>例如：<br>int 可以容纳：1、2、3、4、68、72、256 等<br>浮动可以保持：1.54、55.55、1.24、5.657、8.8123 等<br>字符可以容纳： A， B， C， D， E， F， ！， 4， 5， 6， P <br>",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型告诉编译器函数名称、其返回类型及其参数的类型，其中函数定义实际实现成员函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "在函数定义的主体中声明的变量不能在函数之外使用。<br><br>该类的成员函数才能访问数据成员。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "它直接提供访问和修改调用方的参数数据。它消除了复制大量数据的价值开销",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "指向内存中位置的指针。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "当一个人没有明确说明时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数原型用于将编译器引用到稍后将定义的函数，函数定义是实际函数本身，包含返回类型、参数等。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "精炼。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "两者都依赖于重复，都有一个基例，两者都可以变成无限循环。任何递归也可以通过迭代来解决。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "6",
        "question": "在运行程序中声明C++在哪里？",
        "text1": "变量可以在程序的任意位置声明。它们可以在函数（局部变量）内或在函数（全局变量）外部声明",
        "text2": "在函数 main（） 中，然后再使用变量。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "使调用函数能够直接访问和修改调用方™的参数数据。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "除设置程序要求外，所有阶段都受到影响。 如果测试失败，它可以更改程序的整个设计、实现等以及最终结果。",
        "label": 0.3,
        "category": "1.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "精炼和编码",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数用于创建可用于程序主函数的对象。 这可能与它一起执行代码，也可能不执行代码。<br><br>一个函数是一组代码，在调用时执行，但不会创建新对象。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "在原型程序中解决高风险问题，以确保程序可行。 原型也可用于向公司显示软件可能进行编程。<br><br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "迭代和递归有许多相似之处：两者都基于控制语句、涉及重复、涉及终止测试、逐渐接近终止并可能发生无限。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "构造函数通常用于实例化数据成员和分配资源，例如内存、文件等。 此外，构造函数不能返回值。 函数是可能全局定义的操作。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "while 循环是预检查（它会在 while 块内执行代码之前检查条件语句）<br><br>当循环是后检查时检查（它检查条件后块执行，它至少运行一次，无论条件语句是什么）",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "文件范围。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "标题文件声明类成员函数。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "整个代码",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "21",
        "question": "迭代和递归之间的相似性是什么？",
        "text1": "它们都涉及重复;他们都有终止测试;它们都可以无限发生。",
        "text2": "他们都使用重复，控件或测试终止，两者都可以无限重复，如果定义不正确。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "每当创建类的实例时，都会自动调用构造函数，用户必须显式调用函数。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "while 循环首先检查条件是否为 true，如果为 true，它将执行语句。<br>一下， 而循环在检查条件之前执行语句。如果条件为真， 它会再次执行语句。而循环将执行语句至少一次。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "10",
        "question": "构造函数和函数的区别是什么？",
        "text1": "每当创建对象时都会调用构造函数，而函数需要显式调用。构造函数没有返回类型，但函数必须指示返回类型。",
        "text2": "与常规函数不同，构造函数仅在创建对象时™对象的数据。构造函数还必须与 类同名，并且不能返回任何值。<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "原型仅显示返回类型和必要参数。该定义包括这些参数的名称，并定义对象实际能够执行哪些操作。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "5",
        "question": "什么是变量？",
        "text1": "内存中可以存储值的位置。",
        "text2": "变量是计算机内存中的值可以存储的位置<br><br>供程序使用。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "对我们来说，它通常是一个集，获取，和显示Messge或其他消息，告诉你什么属性类有，但不显示其实现。您可以在自己的类定义中包含任何您想要的内容。",
        "label": 0.4,
        "category": "2"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "函数主（）。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "整个程序。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "12",
        "question": "可以为类创建多少个构造函数？",
        "text1": "无限数量。",
        "text2": "无限",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "A 做...while 循环将始终执行至少一次，则一<br><br>，具体取决于条件。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "精炼阶段、生产阶段和维护阶段。<br><br>",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "只能在其声明范围内访问局部变量。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "创建一个 comon 区域以包含可重用函数。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "11",
        "question": "何时C++创建默认构造函数？",
        "text1": "如果未提供构造函数，编译器默认提供一个构造函数。如果为类定义了构造函数，编译器不会创建默认构造函数。",
        "text2": "C++构造函数将创建默认构造函数，当没有其他构造函数存在时。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "）） 一段时间和做...而声明？<br>执行，而构造由代码块和条件组成。首先，执行块中的代码，然后评估条件，直到证明为 false。While 循环之间的区别在于，它在执行块中的代码之前测试条件。<br>",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "20",
        "question": "在定义递归函数时，无限递归的可能原因是什么？",
        "text1": "如果递归步骤定义不正确，或者不包括基例。",
        "text2": "没有适当的案例离开递归",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "数据成员和成员函数。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员封装在类或对象中，它是静态的，可以由该类的所有实例共享。<br>然而，局部变量只从声明它的函数或块使用，而不是整个类。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "解决创建程序中的主要问题。没有办法解释程序中所有可能的 Bug，但可以证明程序是有形的。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "测试、精炼、生产和维护。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "属于类的函数和数据成员",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "细化、构建和过渡。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "可由源文件中遵循其声明或定义的任何函数引用",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "4",
        "question": "程序C++在哪里执行？",
        "text1": "在主函数。",
        "text2": "C++程序开始在主函数执行。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "15",
        "question": "函数签名包括哪些内容？",
        "text1": "函数的名称和参数的类型。",
        "text2": "函数签名由函数原型组成。 这将告诉您有关函数、其名称、参数、函数位于什么范围和其他杂项信息的一般信息。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "头文件是用于存储原型函数和数据成员列表的文件。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "2",
        "question": "软件生命周期的哪些阶段受测试阶段的影响？",
        "text1": "测试阶段可以影响编码阶段（阶段 5）和解决方案优化阶段（阶段 7）",
        "text2": "验证、编码、优化解决方案和维护都受测试阶段的影响。",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "19",
        "question": "重载函数如何被编译器区分？",
        "text1": "基于函数签名。调用重载函数时，编译器将查找其签名最接近给定函数调用的函数。",
        "text2": "按参数的数量和类型",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "数据封装概念，使用函数或方法来操作数据。",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "程序内的所有函数均可访问它",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "3",
        "question": "与面向对象的编程相关的主要优势是什么？",
        "text1": "抽象和可重复性。",
        "text2": "面向对象编程的主要优点是数据抽象、更易于维护和可重新可用性。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "7",
        "question": "一段时间和做 ... ...而声明？",
        "text1": "一个里面的方块...而语句将至少执行一次。",
        "text2": "while 语句将仅在满足语句时处理， 而 do...而将始终处理一次，则仅在满足语句时继续。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "8",
        "question": "类定义中通常包含哪些项？",
        "text1": "数据成员（属性）和成员函数。",
        "text2": "类定义通常包含函数及其数据成员",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "14",
        "question": "头文件的作用是什么？",
        "text1": "存储类接口，包括数据成员和成员函数原型。",
        "text2": "头文件的主要作用是它用于在各种文件之间共享信息。",
        "label": 0.6,
        "category": "3"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "functgion 原型是函数的声明，而函数定义指定函数的作用",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员是类的永久属性，当成员函数的范围结束时，成员函数内的局部变量将丢失。",
        "label": 0.8,
        "category": "4"
    },
    {
        "id": "13",
        "question": "函数原型和函数定义有什么区别？",
        "text1": "函数原型包括函数签名，即函数的名称、返回类型和参数的类型。函数定义包括函数的实际正文。",
        "text2": "函数定义是定义放置在 [ 括号中确定该函数操作的函数的代码。<br><br>一个函数原型显示函数的公共接口，而不公开实现。 它显示参数的名称、返回类型和类型。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "字段变量是声明为类成员的变量。局部变量是声明方法的局部变量。",
        "label": 0.5,
        "category": "2.5"
    },
    {
        "id": "16",
        "question": "全局变量的范围是什么？",
        "text1": "文件范围。",
        "text2": "在整个程序执行",
        "label": 0.9,
        "category": "4.5"
    },
    {
        "id": "18",
        "question": "通过引用传递的函数参数的主要优势是什么？",
        "text1": "调用函数时，它避免复制大型数据结构。",
        "text2": "如果通过引用传递，可以修改值，而不是在无法更改值的通过值传递值时修改值",
        "label": 0.7,
        "category": "3.5"
    },
    {
        "id": "9",
        "question": "成员函数内的数据成员和局部变量有什么区别？",
        "text1": "可以从类定义中的任何成员函数访问数据成员。只能在定义本地变量的成员函数内访问本地变量。",
        "text2": "数据成员在类中的任意位置都可以访问，而成员函数中的 i 局部变量仅在该特定函数中可访问，并在函数退出后释放。",
        "label": 1.0,
        "category": "5"
    },
    {
        "id": "1",
        "question": "原型程序在解决问题中的作用是什么？",
        "text1": "模拟所需软件产品部分的行为。",
        "text2": "原型程序给出了最终产品将做什么的一般想法，<br><br>没有时间和精力来写出整个程序。",
        "label": 0.6,
        "category": "3"
    }
]